--- 
title: "Competitive City Report 2020"
author: "Greater Louisville Project"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
link-citations: yes
description: "This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook."
---

# Introduction

This report was created with the Louisville Urban League.

logo!

Thanks to contributors.

<!--chapter:end:index.Rmd-->

---
title: "Black Wealth in Louisville"
output: 
  html_document:
    self_contained: no
    toc: true
    toc_float: true
    code_folding: hide
---

# Black Wealth

```{r setup2, message=FALSE, warning=FALSE}
# Knitr options
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      dev.args=list(bg="transparent"))

library(tidyverse)
library(magrittr)
library(showtext)
library(rgdal)
library(sf)
library(viridis)
library(plotly)
library(tidygeocoder)
library(leaflet)
library(rvest)
library(lubridate)

load("Black_wealth/glptools_exports.RData")
source("Black_wealth/helper_functions.R")

library(showtext)
showtext_auto()

font_add("Montserrat", "Black_wealth/Montserrat/Montserrat-Regular.ttf")
font_add("Montserrat Bold", "Black_wealth/Montserrat/Montserrat-SemiBold.ttf")

jfco_shp <- readOGR("Black_wealth/JC Tracts", layer = "JC Tracts",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

jfco_sf <- st_as_sf(jfco_shp) %>%
  mutate(GEOID = str_sub(GEO_ID, start = -11))
```

```{r xaringan-panelset2, echo=FALSE}
xaringanExtra::use_panelset()
```

## Introduction

There is no universally-accepted definition of wealth within the Black community. Even within the traditional definitions of monetary wealth, there is no direct data on Black Wealth in Louisville. This report looks at the available national data on monetary wealth and then looks at local data in three areas that are closely related to wealth and wealth-building: business ownership, housing finance, and income. 


## Wealth (National)

Wealth data remains scarce in general because the subject of wealth can be sensitive and is not tracked in a comprehensive way. Multiple surveys ask about income, and tax records show yearly income, but this data provides an incomplete picture, often missing key metrics such as property ownership, community investment, inherited wealth, etc. As such, our measures of wealth remain indirect. 

The national Survey of Consumer Finances (SCF), which occurs every three years, is our best source of wealth data. It measures "all assets over which a family has legal claim that can be used to finance its present and future consumption". The most recently available data is from 2019, leaving the impact of the ongoing pandemic undefined. The key findings from the [Federal Reserve report](https://www.federalreserve.gov/econres/notes/feds-notes/disparities-in-wealth-by-race-and-ethnicity-in-the-2019-survey-of-consumer-finances-20200928.htm) include:

- The median white family has \$188,200, while the median Black family has \$24,100, <i>less than 15% of what white families hold.</i> 
- After falling from 2007 to 2013, median Black wealth has increased from 2013-2019; however, the gap between White and Black families remains largely unchanged. 
- The gap in wealth starts at an early age, with white families under 35 having a median wealth of \$25,400 and Black families having \$600. 
- White families are more likely to own homes at any age, but the Black-White gap is largest in households under 35, likely reflecting parental wealth. 

The Federal Reserve Report concludes that inheritances and other sources of family support are the single largest driver of the racial wealth gap. 

## Business Ownership (Local)

Entrepreneurship is a key driver of wealth creation and generational wealth. Business owners are able to build wealth through their companies, and money spent at locally-owned businesses contribute to local wages and neighborhood development.

Data on business ownership are available for all businesses for the Louisville MSA, which includes 9 surrounding counties. At the county level, data on business ownership is only available for "employer businesses": businesses that have at least one employee.

While employer businesses only make up about 20% of local registered businesses, they comprise 98.2% of local business revenue, and so we will focus our analysis there. We do note that while Black residents only own 2.3% of employer businesses in Louisville, they own 9.8% of all businesses in the larger Louisville MSA.

Overall, the data show a large racial disparity in ownership of employer businesses in Louisville.

### Comparison to peer cities

In Jefferson County, Black residents make up 21.9% of the population, and they own 2.3% of employer businesses. The graph below compares this ratio across Louisville's cities. Cities would fall on the solid line if Black residents were represented equally among employer business owners and the population. The dotted line shows the average level of representation of Black residents among employer business owners in Louisville's peer cities. Black residents have higher-than-average representation in cities that fall above the dotted line, and they have below-average representation in cities below the line, but no cities, including Louisville, come close to equal representation. 

```{r}
pct_nonemp_business <- 57630 / (57630 + 14785)
pct_nonemp_revenue <- 2757359000 / (2757359000 + 152432057000)

# glpdata::population_msa_1yr %>% filter(race %in% c("black", "total"), MSA == "31140", year == 2019, sex == "total")

business_ownership_county_clean <- business_ownership_county %>%
  group_by(FIPS, year) %>%
  mutate(
    firm_percent = firms_num / firms_num[sex=="total" & race == "total"] * 100,
    revenue_percent = revenue_num / revenue_num[sex=="total" & race == "total"] * 100) %>%
  ungroup() %>%
  filter(race == "black") %>%
  pull_peers(add_info = T, FIPS_df = FIPS_df) %>%
  filter(current == 1)

business_ownership_county_summary <- business_ownership_county_clean %>%
  filter(FIPS != "21111") %>%
  summarize(avg_ratio = mean(firm_percent / pop_percent)) %>%
  pull(avg_ratio)

business_ownership_county_clean %<>%
  mutate(marker_color = if_else(city == "Louisville", '#d63631', "#000000")) 

lou <- filter(business_ownership_county_clean, city == "Louisville")

a <- list(
  x = lou$pop_percent,
  y = lou$firm_percent,
  text = lou$city,
  xref = "x",
  yref = "y",
  showarrow = F,
  arrowhead = 0,
  ax = 0,
  ay = 10,
  yanchor = "top")

b <- list(
  x = 12,
  y = 11,
  text = "Equal representation",
  xref = "x",
  yref = "y",
  showarrow = F,
  arrowhead = 0,
  ax = 0,
  ay = 30,
  xanchor = "left")

c <- list(
  x = 40,
  y = 7,
  text = "Average representation in peer cities",
  xref = "x",
  yref = "y",
  showarrow = F,
  arrowhead = 0,
  ax = 0,
  ay = -16,
  textangle = -20)

plot_ly(business_ownership_county_clean) %>%
  add_markers(x = ~`pop_percent`, y = ~`firm_percent`, 
              text = business_ownership_county_clean$city,
              color = ~I(marker_color),
              marker = list(size = 10),
              hoverinfo = 'text',
              showlegend = FALSE) %>%
  add_segments(x = 0, xend = 60, 
               y = 0, yend = 60,
               name = "Equality",
               line = list(color = '#323844', width = 1),
              showlegend = FALSE) %>%
  add_segments(x = 0, xend = 60, 
               y = 0, yend = business_ownership_county_summary * 60, 
               name = "Peer Average",
               line = list(color = '#323844', width = 1, dash = 'dash'),
              showlegend = FALSE) %>%
  layout(
    font = list(family = "Montserrat"),
    
    annotations = list(a, b, c),
    
    title = "Black Business Ownership by Peer City",
    xaxis = list(title = "Percent of Residents who are Black"),
    yaxis = list(title = "Percent of Businesses Owned by Black Residents", 
                 range = c(0, 20)))
    
```

### Peer Ranking

This graph shows the number of employer-businesses that Black residents own for every 100 Black residents.

```{r business_ownership_ranking}
ranking(business_ownership_county_clean,
        "firms_num_per_100",
        race = "black",
        plot_title = "Black Business Ownership",
        y_title = "Businesses per 100 residents",
        caption_text = "Source: Greater Louisville Project
                        Data from the Census Bureau Annual Business Survey",
        year = 2017,
        text_size = 2, 
        accuracy = 0.01,
        FIPS_df = FIPS_df)
```

### Local business creation

The map below shows business filings throughout 2020 within Jefferson County. These businesses include any type of LLC, corporation, or nonprofit officially registered with the Commonwealth of Kentucky. Compared to the previous data that focuses on larger organizations, it shows that entrepreneurship is widespread throughout the city.

```{r business_filings}
cols_spec <- cols("organization_number" = col_character(),
                  "comptype" = col_number(),
                  "compseq" = col_character(),
                  "name" = col_character(),
                  "standing" = col_character(),
                  "status" = col_character(),
                  "org_country" = col_character(),
                  "org_state" = col_character(),
                  "company_type" = col_character(),
                  "registered_agent_name" = col_character(),
                  "registered_agent_address_1" = col_character(),
                  "registered_agent_address_2" = col_character(),
                  "registered_agent_address_3" = col_character(),
                  "registered_agent_address_4" = col_character(),
                  "registered_agent_city" = col_character(),
                  "registered_agent_state" = col_character(),
                  "registered_agent_zip" = col_character(),
                  "address_1" = col_character(),
                  "address_2" = col_character(),
                  "address_3" = col_character(),
                  "address_4" = col_character(),
                  "city" = col_character(),
                  "state" = col_character(),
                  "zip" = col_character(),
                  "file_date" = col_date("%m/%d/%Y"),
                  "organization_date" = col_date("%m/%d/%Y"),
                  "authorization_date" = col_date("%m/%d/%Y"),
                  "record_date" = col_date("%m/%d/%Y"),
                  "registered_agent_res_date" = col_date("%m/%d/%Y"),
                  "expiration_date" = col_date("%m/%d/%Y"),
                  "renewal_date" = col_date("%m/%d/%Y"),
                  "numofcr" = col_skip(), 
                  "numofshr" = col_skip(), 
                  "mangnum" = col_skip(),
                  "applname" = col_skip(), 
                  "appltitl" = col_skip(), 
                  "parpre" = col_skip(),
                  "parcomno" = col_skip(),
                  "parcom" = col_skip(),
                  "parpreno" = col_skip(),
                  "for_profit" = col_character(),
                  "record_num" = col_character())

#File available at https://drive.google.com/file/d/1cTCZK0A4XTru3HYPLLbDnu0DoKHlB5l1/view?usp=sharing

all_companies <- read_tsv("Black_wealth/AllCompanies20210430.txt",
                          col_names = names(cols_spec$cols),
                          col_types = cols_spec,
                          quote = "")

# Select one record per organization, excluding name reservations
all_companies %<>% 
  filter(compseq == "99999", 
         comptype %not_in% c(1, 2, 3, 4, 7, 11, 12, 13, 14),
         year(file_date) >= 2000)

lou_zips <- glptools::FIPS_zip %>% 
  filter(FIPS == "21111") %>%
  pull(zip) %>%
  as.numeric()

all_companies %<>% filter(zip %in% lou_zips)

zip_pop <- glpdata::population_zip %>%
  filter(race == "total", sex == "total", year == 2018)

t = glpdata::population_zip %>% 
  filter(FIPS == "21111", sex == "total", race == "total", year == 2019)

all_companies_zip <- all_companies %>%
  left_join(t) %>%
  filter(year(file_date) == 2020) %>%
  group_by(zip) %>%
  summarize(num_companies = n(),
            pct_here = mean(population_in_FIPS / population_total),
            pct_here = if_else(is.na(pct_here), 1, pct_here)) %>%
  summarize(sum(num_companies * pct_here))
  
all_companies_zip <- all_companies %>%
  filter(year(file_date) == 2020) %>%
  group_by(zip) %>%
  summarize(num_companies = n()) %>%
  left_join(zip_pop, by = "zip") %>%
  mutate(companies_pp = num_companies / population_total * 100,
         companies_pp = if_else(zip %in% c(40209, 40025, 40202), NA_real_, companies_pp))

ggplot(left_join(map_zip, all_companies_zip, by = "zip")) + 
  geom_sf(aes(fill = companies_pp)) +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  scale_fill_viridis(name = "Filings per\n100 Residents") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        legend.title = element_text(size = 18, lineheight = 0.6),
        plot.caption = element_text(lineheight = 0.6)) +
  labs(title = "Business Filings, 2020",
       caption = "Source: Greater Louisville Project
                  Data from the Kentucky Secretary of State") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

# chunks <- c(seq(1, nrow(all_companies), 1000), nrow(all_companies) + 1)
# 
# for (c in 1:(length(chunks) - 1)) {
#   
#   print(c)
#   
#   temp <- all_companies[chunks[c]:(chunks[c+1] - 1),]
#   
#   this_geo <- temp %>%
#     geocode(
#       street = address_1,
#       city = city,
#       state = state,
#       postalcode = zip,
#       method = "cascade")  
#   
#   output <- assign_row_join(output, this_geo)
# }
```

```{r, eval=FALSE}        
test <- readxl::read_excel("business registration.xlsx")

lou_zips <- glptools::FIPS_zip %>% 
  filter(FIPS == "21111") %>%
  pull(zip) %>%
  as.numeric()

test %<>% filter(`Principal Office Zip` %in% lou_zips)

test %<>%
  transmute(
    Name,
    street = `Principal Office Address 1`,
    city = `Principal Office City`,
    state = "KY",
    postalcode = `Principal Office Zip`)

# Use free default providers first (Census and OSM)
test_cascade <- test %>%
  geocode(
    street = street,
    city = city,
    state = state,
    postalcode = postalcode,
    method = "cascade")

test_map <- st_as_sf(test_cascade,
                     coords = c("long", "lat"), 
                     crs = 4326)

st_crs(jfco_sf) <- 4326

t=st_filter(test_map, jfco_sf)

leaflet(t) %>%
  addTiles() %>%
  addCircleMarkers(label = t$Name)
```

## Homeownership (Local)

Homeownership represents a significant component of wealth. Housing reflects historical wealth patterns––parental wealth makes it easier to buy a home––and is a major generator of wealth--historically, homes in most neighborhoods have risen in value, increasing the wealth of those who own them. 

The data show stark divides between Black and white families throughout the homeownership process, demonstrating one aspect of the wealth gap. 

### Home Mortgages

#### Mortgages by geography

In 2019, about 3.8 mortgages were issued per 100 residents in Jefferson County; however, the availability of mortgages varies greatly across the city. Two census tracts saw 0 mortgages issued in 2019, and most of West Louisville saw fewer than 1 mortgage issued per 100 residents. Often mortgage issuance is limited by a loan to value ratio that reflects property values in a given neighborhood relative to the replacement value of the structure Mortgage issuance is much higher in neighborhoods with higher overall value or new construction.

```{r mortgages_per_person_bw}
home_loan_tract_race <- home_loan_tract %>%
  filter(year == 2019, sex == "total", race != "total") %>%
  select(tract, race, denial:rate_spread)

home_loan_tract %<>%
  filter(year == 2019, sex == "total", race == "total") %>%
  select(tract, denial:rate_spread)

jfco_sf %<>% left_join(home_loan_tract, by = c("GEOID" = "tract"))

loan_num_labs <- c("No mortgages", "Less than 1", "1 to 3", "3 to 5", "5 to 10", "More than 10")

jfco_sf %<>%
  mutate(
    loan_num_fill = 
      case_when(
        loan_number_per_100 == 0 ~ loan_num_labs[1],
        loan_number_per_100 <= 1 ~ loan_num_labs[2],
        loan_number_per_100 <= 3 ~ loan_num_labs[3],
        loan_number_per_100 <= 5 ~ loan_num_labs[4],
        loan_number_per_100 <= 10 ~ loan_num_labs[5],
        loan_number_per_100 > 10 ~ loan_num_labs[6],
        is.na(loan_number_per_100) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = loan_num_labs, ordered = TRUE))

ggplot(jfco_sf) + 
  geom_sf(aes(fill = loan_num_fill)) +
  scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        legend.title = element_blank(),
        plot.caption = element_text(lineheight = 0.6)) +
  labs(title = "Mortgages issued per 100 residents in 2019",
       caption = "Source: Greater Louisville Project
                  GLP analysis of data from the Consumer Financial Protection Bureau") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))
```

#### Mortgages by race

We can also examine mortgage data by race. Black residents in Louisville received fewer than half the number of mortgages per person that White residents did in 2019.

```{r mortgage_number_race_bw}

# Interactive Mortgage map
# load("home_loans_detail.RData")
# home_loan_detail %<>%
#   select(tract, year, race, sex, loan_status, income, loan, rate) %>%
#   mutate(tract = str_extract(tract, "21111.*")) %>%
#   filter(year == 2019, loan_status == "approved")
# 
# num_points <- home_loan_detail %>%
#   group_by(tract) %>%
#   summarise(n = n(), .groups="drop") %>%
#   left_join(glptools::map_tract, by = "tract") %>%
#   group_by(tract) %>%
#   nest() %>%
#   mutate(points = map(data, function(x) st_sample(x$geometry, x$n))) %>%
#   unnest()
# 
# home_loan_detail %<>% arrange(tract)
# num_points %<>% arrange(tract)
# 
# st_geometry(home_loan_detail) <- num_points$points
# 
# library(leaflet)
# 
# 
# fillpal <- colorFactor(RColorBrewer::brewer.pal(5, "Dark2"), domain = unique(home_loan_detail$race))
# 
# leaflet(filter(home_loan_detail, is.na(race))) %>%
#   addCircleMarkers(
#     radius = ~sqrt(loan / 30000),
#     #radius = 5,
#     stroke=T,
#     fillColor = ~fillpal(race),
#     color = ~fillpal(race),
#     weight = 1,
#     fillOpacity = 0.15,
#     opacity = 0.4) %>%
#   addLegend(pal = fillpal, values = unique(home_loan_detail$race)) %>%
#   addTiles()


mortgage_county <- home_loan_county

mortgage_county %<>% filter(FIPS == "21111", sex=="total", race %in% c("black", "white")) %>%
  rename(Race = race) %>%
  mutate(Race = str_to_title(Race))

plt_by(mortgage_county, Race, loan_number_per_100, "Mortgages by race", y_axis = "Mortgages per 100 People", y_min = 0,
       caption_text = "Source: Greater Louisville Project
                  GLP analysis of data from the Consumer Financial Protection Bureau")
```

#### Mortgage Dollars by race

The racial disparity in mortgages is even larger when you incorporate the dollar amount of mortgages issued. In 2019, white residents received \$2.60 in mortgages for every \$1 that Black residents received after adjusting for population size.

```{r mortgage_dollars_race_bw}
plt_by(mortgage_county, Race, loan_amount_pp, "Mortgage Lending by race", y_axis = "Dollars per 100 People", y_min = 0,
       units = "Dollars",
       caption_text = "Source: Greater Louisville Project
                       GLP analysis of data from the Consumer Financial Protection Bureau")
```


#### Denial Rates by Race

Black residents are denied mortgages at a rate roughly twice that of white residents. The mortgage denial rate for Black residents has decreased from a high of 29% in 2008 to a low of 14% in 2019. However, it has not shown signs of decreasing in recent years, and Black residents are more likely to be impacted by the economic impacts of COVID-19, worsening the disparity in 2020 and beyond.

```{r mortgage_denial_race_bw}
plt_by(mortgage_county, Race, denial, "Mortgage Denial by race", y_axis = "Denial Rate", y_min = 0, units= "Percent",
       caption_text = "Source: Greater Louisville Project
                       GLP analysis of data from the Consumer Financial Protection Bureau")
```

#### Denial Rates by Geography

A major factor in mortgage availability is denial rates. While some areas of town saw few to no mortgage denials, people in many parts of West Louisville experienced denial rates of 30 to 40%.

```{r mortgage_denial_bw}
make_map(denial, title = "Mortgage Denial Rate in 2019", 
         legend = "Percent", 
         caption = "Source: Greater Louisville Project
                    GLP analysis of data from the Consumer Financial Protection Bureau",
         map_obj = jfco_sf)
```

#### Interest Rates by geography

For the mortgages that were issued, interest rates varied from around 3.5% to around 5%. While the average interest rate was around 4% for the much of East Louisville, average interest rates in West Louisville were closer to 5%. A 30-year mortgage with an interest rate of 5% requires monthly payments that are 13% higher than a mortgage with an interest rate of 4%.

```{r mortgage_interest_bw}
make_map(rate, title = "Mortgage Interest Rate in 2019", 
         legend = "Percent",
         caption = "Source: Greater Louisville Project
                    GLP analysis of data from the Consumer Financial Protection Bureau",
         map_obj = jfco_sf)
```

### Housing Price Changes

As Louisville grows, increasing home prices reflect changes in inflation and increasing demand for homes. Long-term growth in home prices helps homeowners build equity and wealth. Short-term appreciation can be a boon to homeowners with the finances to stay in their home, though it also causes many homeowners and renters to be dislocated from their neighborhood.

#### Long-term appreciation

This map shows the change in existing home prices across zip codes since 2000 in Jefferson County, controlling for new construction. Since 2000, existing homes in Louisville have increased in value by an average of 62% after accounting for inflation, an average of about 2.4% per year. However, not every area of the city has benefited equally from this growth. Home prices in zip code 40204, which contains the Upper Highlands and Germantown, have more than doubled since 2000. While many zip codes close to downtown also saw high growth, many parts of West Louisville saw slow growth.

```{r long_term_appreciation_bw}
lou_num <- HPI_county %>% filter(FIPS == "21111")

housing_price_index <- HPI_zip

housing_price_index %<>% 
  filter(year == 2020)

map_zip %<>% left_join(housing_price_index, by = "zip")

hpi_change <- c("Lost value", "0% - 25%", "25% - 50%", "50% - 75%", "75% - 100%", "100% - 125%")

hpi_2015_change <- c("Lost value", "0% - 10%", "10% - 20%", "20% - 30%", "30% - 40%", "40% - 50%")

map_zip %<>%
  mutate(
    hpi_fill = 
      case_when(
        HPI < 100 ~ hpi_change[1],
        HPI < 125 ~ hpi_change[2],
        HPI < 150 ~ hpi_change[3],
        HPI < 175 ~ hpi_change[4],
        HPI < 200 ~ hpi_change[5],
        HPI < 225 ~ hpi_change[6],
        is.na(HPI) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = hpi_change, ordered = TRUE),
    hpi_2015_fill = 
      case_when(
        HPI5 < 0 ~ hpi_2015_change[1],
        HPI5 < 10 ~ hpi_2015_change[2],
        HPI5 < 20 ~ hpi_2015_change[3],
        HPI5 < 30 ~ hpi_2015_change[4],
        HPI5 < 40 ~ hpi_2015_change[5],
        HPI5 < 50 ~ hpi_2015_change[6],
        is.na(HPI) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = hpi_2015_change, ordered = TRUE))

ggplot(map_zip) + 
  geom_sf(aes(fill = HPI - 100)) +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  scale_fill_viridis(breaks = c(25, 50, 75, 100, 125), 
                     limits = c(24, 126),
                     name = "Percent Increase") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        plot.caption = element_text(lineheight = 0.6)) +
  labs(title = "Change in housing prices since 2000",
       caption = "Source: Greater Louisville Project
                  Data from Federal Housing Finance Agency HPI Tables") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))
```

#### Short-term appreciation

Looking at the growth since 2015 highlights zip codes where changes in home prices have been very acute. The average home in Louisville increased in value by 24% between 2015 and 2020. Most zip codes saw total growth of 20% - 35%, while changes in home prices for zip codes in West Louisville range from an increase of 15% in 40212 to an increase of 46% in 40203. Home prices in 40203 have increased by an average of 7.9% per year since 2015, and they threaten to displace many residents from parts of Russell and Old Louisville. 

```{r short_term_appreciation_bw}
ggplot(map_zip) + 
  geom_sf(aes(fill = HPI5)) +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  scale_fill_viridis(name = "Percent Increase") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        plot.caption = element_text(lineheight = 0.6)) +
  labs(title = "Change in housing prices since 2015",
       caption = "Source: Greater Louisville Project
                  Data from Federal Housing Finance Agency HPI Tables") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```

### Home Valuation by Geography


According to [research by Dr. Andre Perry at the Brookings Institute](https://www.brookings.edu/research/devaluation-of-assets-in-black-neighborhoods/), owner-occupied homes in Black neighborhoods are, on average, undervalued by $48,000 per house in the U.S. In the Louisville Metro Area, the median home value in majority Black neighborhoods is \$89,681, but would be \$117,593 if houses were not devalued, according to the same research. This difference constitutes a 27% undervaluation from what home values in Black neighborhoods would be if based on structural characteristics (e.g. sq. ft, year built) and neighborhood amenities (e.g. walkability, school districts, commute time) alone.

```{r devaluation_ranking}
devaluation <- read_csv("Black_wealth/devaluation.csv")

ranking_switch <- function(df, var, plot_title = "",
                    year = NULL, sex = "total", race = "total",
                    order = "Descending",
                    y_title = "Percent",
                    caption_text = "", subtitle_text = "",
                    bar_label = TRUE, sigfig = 3, accuracy = 0.1,
                    label_function, alternate_text = NULL,
                    ranking_colors = TRUE, text_size, FIPS_df){

  # Copy variable var to a new column for use with the '$' operator
  var <- dplyr:::tbl_at_vars(df, vars(!!enquo(var)))
  df$var <- df[[var]]
  # Filter to sex, race, and year
  if ("sex" %in% names(df)) df <- df[df$sex == sex,]
  if ("race" %in% names(df)) df <- df[df$race == race,]
  if("year" %in% names(df)) {
    df <- df[df$year %in% year,]
    if (length(year) > 1) {
      df %<>%
        group_by_at(df %cols_in% c("MSA", "FIPS")) %>%
        summarise(var = mean(var, na.rm = TRUE)) %>%
        ungroup()
    }
  }
  # Add peer data if not already present
   if ("city" %not_in% names(df)) {
     df %<>%
       pull_peers(add_info = T, FIPS_df = FIPS_df) %>%
       filter(current == 1)
   }

  # Sort according to order parameter
  if (order %in% c("descending", "Descending")) df %<>% arrange(desc(var))
  if (order %in% c("ascending", "Ascending"))   df %<>% arrange(var)
  df %<>% filter(!is.na(var))
  # Create numbered city labels for left side of graph
  df %<>%
    mutate(
      rank = row_number(),
      names = paste0(rank, ". ", city))
  # Set bar colors
  if (ranking_colors) {
    # color_values <- c("#96ca4f", "#ffd600", "#db2834")
    # color_names <- c("green", "yellow", "red")
    # if (order %in% c("descending", "Descending")) {color_names  = rev(color_names)}
    #
    # breaks <- classInt::classIntervals(na.omit(df$var), 3, style = "jenks")
    # df$color <- NA
    # df$color[df$var <= breaks$brks[2]] <- color_names[1]
    # df$color[df$var > breaks$brks[2] & df$var <= breaks$brks[3]] <- color_names[2]
    # df$color[df$var > breaks$brks[3]] <- color_names[3]

    color_values <- c("#323844", "#d63631")
    color_names <- c("gray", "red")

    df$color <- "red"
    df$color[df$city == "Louisville"] <- "gray"
  } else {
    df$color <- "blue"
    color_values <- "#f58021"
    color_names <- "blue"
  }
  #if (order %in% c("descending", "Descending")) color_values = rev(color_values)
  color_values = rev(color_values)
  # Create numeric labels
  # Create numeric labels
  if (!missing(label_function)) {
    label_text <- df$var %>% signif(sigfig) %>% label_function()
  } else if (y_title %in% c("Dollars", "Hourly Wage")) {
    if(mean(df$var, na.rm = TRUE) > 10000) {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = accuracy, scale = .001, suffix = "k")
    } else {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = .01)
    }
  } else if (stringr::str_detect(y_title, "Percent")) {
    label_text <- df$var %>% signif(sigfig) %>% scales::percent(accuracy = accuracy, scale = 1, suffix = "%")
  } else {
    label_text <- df$var %>% signif(sigfig) %>% scales::comma(accuracy = accuracy)
  }

  # Set text format, highlight and italicise Louisville text, highlight Louisville bar
  df$textcolor <- "#000000"
  df$textcolor[df$city %in% c("Nashville", "Greenville", "Oklahoma City", "Louisville")] <- "#000000"

  df$textfont <- "Montserrat"
  df$textfont[df$city == "Louisville"] <- "Montserrat Bold"

  label_color_names <- c("white", "black")
  label_color_values <- c("#000000", "#ffffff")

  df$label_color <- "white"
  df$label_color[df$city %in% c("Nashville", "Greenville", "Oklahoma City", "Louisville")] <- "black"
  #df$linecolor <- "#ffffff"
  #df$linecolor[df$city == "Louisville"] <- "#00a9b7"
  df$lou <- if_else(df$city == "Louisville", 1, 0)
  df$text_alignment <- 1.1
  if (!is.null(alternate_text)) df$text_alignment[df$rank %in% alternate_text] <- -0.1
  ### PLOT GRAPH

  # Initial plot
  p <- ggplot(data = df,
              aes(x = factor(names, levels = rev(names)),
                  y = var,
                  fill  = factor(color, levels = color_names, ordered = TRUE)))
  p <- p + guides(fill = FALSE, color = FALSE)
  # Add bars
  p <- p +
    geom_bar(stat = "identity",
             size = text_size) +
    coord_flip() +
    ggthemes::theme_tufte()
  p <- p + scale_fill_manual(values = color_values)
  #p <- p + scale_color_manual(values = c("#ffffff", "#00a9b7"))
  # Add features
  title_scale <- min(1, 48 / nchar(plot_title))
  p <- p + theme(text = element_text(family = "Montserrat"),
                 plot.title = element_text(size = 14 * title_scale * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
                 axis.text.y = element_text(hjust = 0,
                                            size = 10 * text_size,
                                            color = rev(df$textcolor),
                                            family = rev(df$textfont)),
                 axis.title.x = element_text(size = 10 * text_size),
                 axis.ticks = element_blank(),
                 axis.text.x = element_blank(),
                 plot.caption = element_text(size = 10 * text_size, lineheight = 0.5))
  if(subtitle_text != ""){
    p <- p +
      labs(subtitle = subtitle_text) +
      theme(plot.subtitle = element_text(hjust = 0.5, size = 10 * text_size))

  }
  # Add numeric labels to bars based on bar_label parameter
  if (y_title != "" & bar_label) {
    p <- p + geom_text(aes(label = label_text,
                           hjust = text_alignment,
                           color = factor(label_color),
                           family = textfont),
                       size = 4.5 * text_size) +
      scale_colour_manual(values=c("#000000", "#ffffff"))
  }
  # Add vertical line to the left side of the bars based on the h_line parameter
  if (min(df$var, na.rm = TRUE) < 0) p <- p + geom_hline(yintercept = 0, linetype = "longdash", size = 2)
  # Add remaining text
  p <- p + labs(title = plot_title,
                y = y_title,
                x = "",
                caption = caption_text)

  p <- p +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent", colour = NA))
  
  p <- p + expand_limits(y = 15)

  p
}

ranking_switch(devaluation,
        devaluation,
        plot_title = "Devaluation of Homes in Black Neighborhoods",
        text_size = 2, 
        alternate_text=1:17,
        FIPS_df = FIPS_df,
        caption = "Source: Greater Louisville Project
                   Data from Dr. Andre Perry, Brookings Institute")
```

### Property Taxes

While facing lower home values on the market, homes in majority-Black neighborhoods are valued relatively-higher than homes in majority-white by the property tax administration, and thus face [higher taxation relative to the market value of their homes](https://www.washingtonpost.com/context/the-assessment-gap-racial-inequalities-in-property-taxation/215957a4-d5ad-47cd-821a-070cf23b6bc7/). 

The Jefferson County Property Value Administration (PVA) assesses homes every three years to determine their value, and that value is used to determine the amount of property taxes the owner owes. The PVA compares homes to similar nearby properties to determine an appropriate valuation. Based on a comparison of property tax assessments to actual sale prices, data shows that property valuations tend to overvalue homes in some neighborhoods and undervalue them in others, resulting in different property tax rates for owners. There are numerous

#### Property Assessments

The map below compares property assessments to market values. Negative values indicate that home assessments are usually lower than their market price, while postive values indicate that home assessments are, on average, higher than their market price.

Properties inside the Watterson and East of I-65 are consistently valued, and thus taxed, at a lower rate than they are worth. Most over-assessments can be found in Southwest and South Louisville.

There are numerous potential reasons for these discrepancies. One significant factor in Louisville is that homes are usually assessed every three years. In neighborhoods where home values consistently go up, market values quickly increase beyond assessment values. In neighborhoods where home values increase more slowly, market prices usually stay close to property assessments. Several other potential reasons are described in detail in the research linked above.

```{r assessment}
# Load Property tax analysis webpage
page <- read_html("Black_wealth/An Evaluation of Property Tax Regressivity in Jefferson County, Kentucky.html") 

# Extract sales ratio and property tax rate data-for elements
sales_ratio_html = page %>% html_elements('script[data-for="htmlwidget-0527b478a846743b2dd4"]')
property_tax_html = page %>% html_elements('script[data-for="htmlwidget-a1602585f74d11977716"]')

sales_ratio_html %<>% html_text()
property_tax_html %<>% html_text()

# Extract relevant component and split long text strings on commas (by census tract)
sales_ratio_text <- sales_ratio_html %>%
  str_extract('<strong>Census Tract 2, .*300,200(?="])') %>%
  str_split('","')

property_tax_text <- property_tax_html %>%
  str_extract('<strong>Census Tract 2, .*300,200(?="])') %>%
  str_split('","')

# Convert to data frame and extract components using regex
tax_data <- data.frame(
  sales_ratio_raw = sales_ratio_text[[1]],
  property_tax_raw = property_tax_text[[1]])

tax_data %<>%
  mutate(
    # 'Census Tract ' followed by 1-6 characters before a comma
    sr_tract = str_extract(sales_ratio_raw, "(?<=Census Tract ).{1,6}(?=,)"),
    
    # 'Sales in Sample): ' followed by 3-5 characters before %
    sr_ratio = str_extract(sales_ratio_raw, "(?<=Sales in Sample\\)\\: ).{3,5}(?=\\%)"),
    
    # '( ' followed by any number of digits before ')'
    sr_sample = str_extract(sales_ratio_raw, "(?<=\\()\\d*(?=\\))"),
    
    # 'Median Home Value: $' followed by the rest of the string
    home_value = str_extract(sales_ratio_raw, "(?<=Median Home Value\\: \\$).*"),
    
    # 'Percent White Population: ' followed by 3-5 characters before %
    white = str_extract(sales_ratio_raw, "(?<=Percent White Population\\: ).{3,5}(?=\\%)"),
    
    # 'Census Tract ' followed by 1-6 characters before a comma
    pt_tract = str_extract(property_tax_raw, "(?<=Census Tract ).{1,6}(?=,)"),
    
    # 'Sales in Sample): ' followed by 3-5 characters before %
    pt_rate = str_extract(property_tax_raw, "(?<=Sales in Sample\\)\\: ).{3,5}(?=\\%)"),
    
    # '( ' followed by any number of digits before ')'
    pt_sample = str_extract(property_tax_raw, "(?<=\\()\\d*(?=\\))"))

# Check: tract and sample size match across all tracts. TRUE
# all(tax_data$sr_tract == tax_data$pt_tract)
# all(tax_data$sr_sample == tax_data$pt_sample)

# Create tract IDs and clean data frame
tax_data %<>%
  mutate(
    tract_start = 
      str_extract(sr_tract, "\\d{1,3}") %>% 
      str_pad(4, "left", "0"),
    tract_end = 
      str_extract(sr_tract, "(?<=\\.)\\d{1,2}") %>% 
      replace_na("00") %>%
      str_pad(2, "left", "0"),
    tract = paste0("21111", tract_start, tract_end)) %>%
  transmute(
    tract,
    sales_ratio = as.numeric(sr_ratio),
    property_tax = as.numeric(pt_rate),
    sample_size = as.numeric(sr_sample),
    pct_white = as.numeric(white),
    median_value = as.numeric(str_remove(home_value, ",")))

tax_data %<>%
  mutate(
    dif = sales_ratio - 100,
    dif_bins = 
      case_when(dif < -10 ~ "10 to 15% lower",
                dif < -5 ~ "5 to 10% lower",
                dif < 0 ~ "0 to 5% lower",
                dif < 5 ~ "0 to 5% higher",
                dif < 10 ~ "5 to 10% higher") %>%
      factor(levels = c("10 to 15% lower", "5 to 10% lower", "0 to 5% lower", "0 to 5% higher", "5 to 10% higher"), ordered = T),
    sales_ratio_bins = 
      case_when(sales_ratio < 90 ~ "85-90",
                sales_ratio < 95 ~ "90-95",
                sales_ratio < 100 ~ "95-100",
                sales_ratio < 105 ~ "100-105",
                sales_ratio < 110 ~ "105-110") %>%
      factor(levels = c("85-90", "90-95", "95-100", "100-105", "105-110"), ordered = T),
    property_tax_bins = 
      case_when(property_tax == 0.8 ~ "0.8%",
                property_tax == 0.9 ~ "0.9%",
                property_tax == 1.0 ~ "1.0%",
                property_tax == 1.1 ~ "1.1%",
                property_tax == 1.2 ~ "1.2%",
                property_tax == 1.3 ~ "1.3%",
                property_tax == 1.4 ~ "1.4%",
                property_tax == 1.5 ~ "1.5%",) %>%
      factor(levels = c("0.8%", "0.9%", "1.0%", "1.1%", "1.2%", "1.3%", "1.4%", "1.5%"), ordered = T))

pop_data <- glpdata::population_tract %>%
  filter(year ==  2016,
         race %in% c("total", "black"),
         sex == "total") %>%
  select(tract, race, population) %>%
  pivot_wider(names_from = race, values_from = population) %>%
  mutate(percent_black = black / total * 100)

tax_data %<>%
  left_join(pop_data, by = "tract")

jfco_sf %<>%
  left_join(tax_data, by = c("GEOID" = "tract"))

make_map_bins <- function(indicator, 
                     title = "", legend = "", caption = "", 
                     no_legend = FALSE, vir_dir = 1, bins, shapefile){
  plt <- ggplot(shapefile) +
    geom_sf(aes(fill={{ indicator }} )) +
    # scale_fill_gradient(low = "#323844", high = "#d63631", name = "Percent") +
    scale_fill_viridis(na.value = "grey", name = legend, direction = vir_dir,
                       discrete = T) +
    theme_bw(base_size = 22) +
    theme(plot.caption = element_text(lineheight = .5)) +
    theme(text = element_text(family = "Montserrat"),
          panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.border = element_blank()) +
    labs(title = title,
         caption = caption)

  if (no_legend == TRUE){
    plt <- plt + theme(legend.position = "none")
  }

  plt <- plt +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA))

  return(plt)
}

make_map_bins(dif_bins, 
              title = "Assessed Value compared to Market Value",
              bins = c(-15, -10, -5, 0, 5, 10),
              caption = "Source: Greater Louisville Project
                         GLP analysis of data from University of Chicago Harris Public Policy",
              shapefile = jfco_sf)
```

#### Property Taxes

The property tax rate for homeowners differs by location. Most homeowners across the county pay taxes toward JCPS, and most homeowners who live inside the Watterson also pay taxes to the Urban Services District. Independent cities, fire departments, and school districts charge different rates throughout the county. As a result, there is no consistent property tax rate throughout Jefferson County. Differences in property tax rates are a result of both local tax rates and property assessments.

The map below shows the effective property tax rate, or the amount of property tax homeowners paid based on the market value of their homes. The majority of homeowners pay a property tax of around 1% of their home's value. Homeowners in some neighborhoods pay slightly less, and many pay slightly more. The highest effective tax rates are found in West Louisville due to a combination of high property assessments relative to homes' values, and the property tax rate for the Urban Services District. 

```{r tax_rate}
make_map_bins(property_tax_bins,
         title = "Effective Property Tax Rate",
         legend = "Percent of Home Value",
         caption = "Source: Greater Louisville Project
                    GLP analysis of data from University of Chicago Harris Public Policy",
         shapefile = jfco_sf)
```

### Undervaluation and Overtaxation

This image summarizes the previous two sections (home valuation and property assessments). If homes in Black neighborhoods were valued by the market and taxed by the city like homes in other neighborhoods, homeowners in those neighborhoods would have higher-priced homes taxed at a lower rate.

![Home valuation and taxation](home_taxes_GLP.png)
*This follows Dr. Andre Perry's (Brookings Institute) methodology in defining a majority Black neighborhood as one with ≥ 50% Black residents.

**The data on the right reflects a home price without devaluation and the average effective property tax rate of white neighborhoods in Louisville. These differences are likely not a completely just or equitable reality, but one that moves us closer to that. 

```{r, eval=FALSE}
# average property tax vs average property tax in a Black neighborhood
tax_data_bn <- tax_data %>%
  filter(percent_black >=50) %>%
  #summarize(prop_tax = mean(property_tax, na.rm=T))
  summarize(prop_tax = weighted.mean(property_tax, sample_size, na.rm=T)) %>% 
  pull(prop_tax)

t=tax_data %>%
  left_join(glptools::nh_tract) %>%
  group_by(pct_white<50) %>%
  summarize(
    sales_ratio = weighted.mean(sales_ratio, sample_size, na.rm=T),
    
    pct_white = mean(pct_white, na.rm=T))

ggplot(tax_data, aes(x=percent_black, y=sales_ratio)) +
  geom_point() +
  geom_smooth() +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        legend.title = element_blank()) +
  labs(title = "Neighborhoods by Assessment Ratio and Race") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA)) +
  labs(x = "Percent of Residents who are Black",
       y = "Assessment Ratio")

# Method 1: Summarize daata for each group based on Dr. Perry's definitions
nb_sales_ratio <- tax_data %>% 
  filter(percent_black <= 1) %>%
  summarize(output = weighted.mean(sales_ratio, sample_size)) %>%
  pull(output)

black_ratio <- tax_data %>% 
  filter(percent_black >= 50) %>%
  summarize(output = weighted.mean(sales_ratio, sample_size, na.rm=T)) %>%
  pull(output)

# Method 2: Summarize data for each group based on the 10% most- and 10% least-Black neighborhoods
nb_sales_ratio <- tax_data %>% 
  filter(percent_black <= quantile(percent_black, 0.1)) %>%
  summarize(output = weighted.mean(sales_ratio, sample_size)) %>%
  pull(output)

black_ratio <- tax_data %>% 
  filter(percent_black >= quantile(percent_black, 0.9)) %>%
  summarize(output = weighted.mean(sales_ratio, sample_size, na.rm=T)) %>%
  pull(output)

prop_ratio <- nb_sales_ratio / black_ratio * tax_data_bn

# Method 3: model data using splines
library(splines)

t=lm(sales_ratio~bs(percent_black, knots = quantile(tax_data$percent_black, c(0.25, 0.5, 0.75))), data=tax_data)

plot(predict(t, newdata = list(percent_black = c(0:100))),ylim=c(85, 110),type="l")
points(tax_data$percent_black, tax_data$sales_ratio)

predict(t, newdata = list(percent_black = 0))

predict(t, newdata = list(percent_black = 50:100)) %>% mean()

test <- glptools::map_muw

test_pop <- glpdata::population_muw %>%
  filter(year == 2016, sex == "total", race %in% c("black", "total")) %>%
  select(-population_change, -population_change_adj) %>%
  pivot_wider(values_from = population, names_from = race)

test %<>% 
  left_join(test_pop) %>%
  mutate(pct_black = black / total * 100)

leaflet(test) %>%
  addTiles()%>%
  addPolygons(fill = test$pct_black >= 50)
  
library(glptools)

housing_vars_05_5yr <- build_census_var_df("acs5", "B25077")
housing_map <- get_census(filter(housing_vars_05_5yr, year == 2019), "tract")

pop_map <- glpdata::population_tract %>%
  filter(year == 2016, sex == "total", race == "total") %>%
  select(tract, population)

t=housing_map %>%
  select(tract, year, var_type, value) %>%
  pivot_vartype_wider(value) %>%
  left_join(muw_tract, by = "tract") %>%
  left_join(pop_data, by = "tract") %>%
  filter(neighborhood %not_in% c("Airport", "Minor Lane Heights")) %>%
  mutate(
    estimate = if_else(estimate %in% c(9999, -666666666), NA_real_, estimate),
    MOE = if_else(MOE %in% c(-333333333, -222222222), NA_real_, MOE))

black_neighborhood_summary <- t %>%
  group_by(percent_black >= 50) %>%
  summarize(
    #estimate = weighted.mean(estimate, total, na.rm = T),
    estimate = Hmisc::wtd.quantile(estimate, total, probs = 0.5, na.rm = T),
    MOE = sqrt(sum(MOE^2)))

neighborhood_summary <- t %>%
  group_by(neighborhood) %>%
  summarize(
    estimate = weighted.mean(estimate, population),
    MOE = sqrt(sum(MOE^2)))

housing_vars_05_5yr <- build_census_var_df("acs5", "B25082")
housing_map <- get_census(housing_vars_05_5yr, "tract") %>% filter(year == 2017)

t=housing_map %>% 
  filter(label == "Estimate!!Aggregate value (dollars):",
         var_type == "estimate") %>%
  mutate(value = if_else(value == -666666666, NA_real_, value)) %>%
  left_join(pop_data, by = "tract") %>%
  group_by(percent_black >= 50) %>%
  summarize(agg_value = sum(value, na.rm = TRUE))



```

### Homeownership Rates

Black families both start with less wealth (and therefore less opportunities to build on it even in a ‘fair’ market) and this is compountded at each step of the home ownership process. 

#### Ranking

Slightly more than 1 in 3 Black Louisville residents own their own homes. While this is roughly toward the middle of our peer cities, it is roughly half the homeownership rate among white residents.

```{r black_homeownership_ranking}
housing_df <- housing_county %>%
  filter(var_type == "percent") 

housing_df_gap <- housing_df %>%
  filter(sex == "total", race %in% c("black", "white"), var_type == "percent") %>%
  select(FIPS, year, race, homeownership) %>%
  pivot_wider(values_from = homeownership, names_from = race) %>%
  mutate(gap = white - black)

ranking(housing_df, 
        homeownership, 
        race = "black",
        year = 2019,
        text_size = 2, 
        FIPS_df = FIPS_df,
        plot_title = "Black Homeownership",
        caption = "Source: Greater Louisville Project
                   GLP analysis of ACS microdata from IPUMS USA")
```

#### Trend

Homeownership among all Louisville residents, including Black residents, has declined slightly since the early 2000s. Since 2010, Louisville's racial homeownership gap has been among the largest of our peer cities.

```{r homeownership_trend}
housing_df_clean <- housing_df %>%
  filter(FIPS == "21111", sex == "total", race %not_in% c("other", "hispanic")) %>%
  mutate(race = str_to_title(race))

plt_by(housing_df_clean,
       race,
       homeownership,
       title_text = "Homeownership by Race",
       caption_text = "Source: Greater Louisville Project
                       GLP analysis of ACS microdata from IPUMS USA")
```

#### Map

Across Louisville, homeownership varies from less than 10% in some areas to the high 90s in others.

```{r homeownership_map}
housing_map_clean <- housing_tract %>%
  filter(sex == "total", race == "total", year == 2017, var_type == "percent") %>%
  select(-sex, -race, -year, -var_type)

jfco_sf %<>%
  left_join(housing_map_clean, by = c("GEOID" = "tract"))

make_map(homeownership, 
         "Homeownership",
         legend = "Percent",
         caption = "Source: Greater Louisville Project
                    ACS table B25106",
         map_obj = jfco_sf)
```

## Household Income (Local)

Many activities that lead to wealth-creation, like starting a business or getting a degree, are not directly tied to income. However, the majority of families build wealth by saving the money they earn. Disparities in income lead to larger disparities in wealth.

### Trendline

While income for Black Households in Louisville has trended up over the last few years, the median Black household only receives about two-thirds the income of the median Louisville household. After adjusting for inflation, median income declined among Black households from 2000 to 2013 and only surpassed their previous levels in 2017.

```{r hh_income_ranking}
hh_income_filtered <- hh_income_county %>%
  filter(var_type == "estimate", 
         race %in% c("black", "total", "white"),
         FIPS == "21111") %>%
  mutate(race = str_to_title(race))

plt_by(hh_income_filtered,
       race,
       hh_income,
       y_axis = "Dollars",
       units = "Dollars",
       title_text = "Household Income by Race",
       subtitle_text = "Adjusted for inflation to 2019 dollars",
       caption_text = "Source: Greater Louisville Project
                       ACS Tables P053, P152, B19013")
```

### Map

The median household income varies widely across Louisville, ranging from under \$20,000 in some areas to over \$150,000 in others.

```{r hh_income_map}
hh_income_tract_clean <- hh_income_tract %>%
  filter(year == 2016,
         race %in% c("total", "black")) %>%
  pivot_wider(names_from = race, values_from = hh_income, names_prefix = "hh_income_") %>%
  select(-year, -sex)

jfco_sf %<>%
  left_join(hh_income_tract_clean, by = c("GEOID" = "tract")) %>%
  mutate(hh_income_black = if_else(hh_income_black < -1000000, NA_real_, hh_income_black))

make_map(hh_income_total, 
         "Median Household income",
         legend = "Dollars",
         caption = "Source: Greater Louisville Project
                    ACS Table B19013",
         map_obj = jfco_sf)
```

## The Tip of the Iceberg 

We have the most data on housing, income, and businesses, but these are not the only areas of wealth building where systemic inequality is pervasive. Black families start with less wealth (and therefore have less opportunities to build on it even in an 'equal’ market) and face discrimination at each step of the process. A better understanding of what metrics are important for describing Black wealth in both quantitative and qualitative terms is important to improve our work in this area, and we welcome input.


<!--chapter:end:Black_wealth.Rmd-->

---
title: "Early Childhood"
author: "Greater Louisville Project"
date: '2021'
output:
  html_document:
    self_contained: no
    toc: yes
    toc_float:
      collapsed: true
    code_folding: hide
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), 'index.html')) })
---

# Early Childhood

```{r setup4, include=FALSE}

# Knitr options
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, dev.args=list(bg="transparent"))

# Set up fonts
library(showtext)
showtext_auto()

font_add("Montserrat", "Black_wealth/Montserrat/Montserrat-Regular.ttf")
font_add("Montserrat Bold", "Black_wealth/Montserrat/Montserrat-SemiBold.ttf")

# Load packages
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(magrittr)
library(purrr)
library(scales)
library(ggrepel)
library(leaflet)
library(sf)
library(plotly)
library(tidygeocoder)
library(viridis)
library(gt)

# Import data and functions from glp packages
source("early-childhood/helper_functions.R")
load("early-childhood/raw_data/glptools_exports.RData")
```

```{r xaringan-panelset4, echo=FALSE}
xaringanExtra::use_panelset()
```

## Introduction

The first few years of a child's life provide the building blocks for lifelong learning and health. While Louisville has a large ecosystem of people, businesses, and organizations that support early childhood development, many families across Louisville face barriers to accessing those resources.

This report analyzes one way to evaluate early childhood development—kindergarten readiness—as well as several factors that impact it: the cost and availability of child care, adverse childhood experiences, and food security. We chose these data based on community interest and with the aim of illuminating topics for which local data is not widely available.

Wherever possible, we analyze the connection between race, geography, and early childhood development. Louisville's early childhood system does not support all populations equally as a result of institutional racism, residential segregation, discriminatory policies, and many other factors. In support of [A Path Forward](https://apathforward4lou.org/), we focus on Black children in particular. However, structural racism does not just affect Black children, and exclusionary policies affect people based on more identities than their race and ethnicity. While we provide some data that extends beyond race, data for other races and populations in our community is often limited, a problem in its own right.

The Greater Louisville Project created this report in conjunction with the [ReadyforK Alliance](http://www.readyforkalliance.com/), whose vision is that all children enter kindergarten ready to thrive.

## Kindergarten Readiness 

Kindergarten readiness is an important indicator of whether children will succeed in the classroom. Based on [data from KySTATS](https://kystats.ky.gov/Reports/Tableau/ECP_2020), JCPS students who entered school ready for kindergarten in 2016 were over three times as likely to achieve test results at or above their grade level on their standardized K-PREP math and reading tests in the 3rd grade. This is true for both JCPS students as a whole and Black JCPS students in particular.

Kentucky school districts evaluate kindergarten readiness using the [BRIGANCE Early Childhood Kindergarten Screen III](https://www.jefferson.kyschools.us/learning/ready4k), which assesses child development across five areas:

*  Academic/Cognitive Development
*  Language Development
*  Physical Development
*  Self-help Skills
*  Social and Emotional Skills

The BRIGANCE screener asks children to perform tasks such as identifying letters, numbers, and shapes or using a writing utensil. Parents provide information on their child's self-help, social, and emotional skills such as whether their child can dress themselves, communicate their feelings, or take turns with other children. The results are a strong indicator of a student's future academic performance. 

It is important to note that the BRIGANCE screener has limitations. For example, children in professional care facilities are more likely to receive instruction tailored to the BRIGRANCE screener than children in a home setting with their parents or a relative. While many of the topics and questions represent important developmental foundations, child development includes factors beyond just the questions in BRIGANCE. It's important to communicate the topics in BRIGRANCE to all families as well as ensure the questions in BRIGRANCE are not culturally biased. 

You can see some of the questions included in BRIGANCE here:

*  [Example child assessment (academic, language, and physical measures)](Documents/BRIGANCE academic language phyical.pdf)
*  [Example parent report (self-help, social, and emotional skills)](Documents/BRIGANCE- Parent ReportShSE Scales English - interactive.pdf)

To view more data on kindergarten readiness, you can visit our [Kindergarten Readiness page](https://greaterlouisvilleproject.org/factors/kready/).

### Overall Readiness

Since JCPS began tracking kindergarten readiness in 2012-13, overall readiness levels have fluctuated up to five percentage points per year but have remained largely unchanged. Other Kentucky students have seen their scores slightly increase.

```{r kindergarten_readiness_total}
load("early-childhood/raw_data/kready_ky.RData")

kready_ky %<>%
  mutate(year = year - 1)

kready_total <- kready_ky %>%
  filter(sex == "total",
         race == "total",
         frl_status == "total",
         prior_setting == "All Students") %>%
  filter(variable %in% c("lou", "mean")) %>%
  mutate(District = if_else(variable == "lou", "JCPS", "Other Kentucky Districts"))

plt_by(kready_total,
       District,
       kready,
       title_text = "Kindergarten Readiness",
       caption_text = "Source: Greater Louisville Project
                       Data from the Kentucky Department of Education School Report Card",
       school = T,
       y_min = 40,
       ymax = 60)
```

### by Race

Racial disparities in kindergarten readiness have been largely persistent since the 2012-13 school year. The kindergarten readiness gap between Black students and white students shrank from 12 points in 2012-13 to around 5 points in 2016-17 before growing again. As of the 2018-19 school year, scores for the four groups included here are all within five points of their original levels.

```{r kready_race}
kready_race <- kready_ky %>%
  filter(variable == "lou",
         sex == "total",
         race %in% c("black", "white", "hispanic", "asian"),
         frl_status == "total",
         prior_setting == "All Students") %>%
  mutate(Race = str_to_title(race))

plt_by(kready_race,
       Race,
       kready,
       school = T,
       title_text = "JCPS Kindergarten Readiness by Race",
       caption_text = "Source: Greater Louisville Project
                       Data from the Kentucky Department of Education School Report Card")
```

### by Prior Setting

The largest differences among kindergarten studnets are based on prior setting.

Children who were in licensed child care providers prior to entering school are most likely to be kindergarten ready, while children who stayed at home with a parent or guardian are least likely to be kindergarten ready.

Children who were previously enrolled in Head Start, a State-funded preschool program, or were in another home setting such as a private sitter or other family member (labeled "Other"), fall in the middle.

```{r kready_prior_setting}
kready_louisville <- kready_ky %>%
  filter(variable == "lou",
         sex == "total",
         race == "total",
         frl_status == "total",
         prior_setting %in% c("State Funded", "Head Start", "Child Care", "Home", "Other")) %>%
  mutate(prior_setting = if_else(prior_setting == "	State Funded", "State-Funded", prior_setting))

kready_louisville2 <- kready_ky %>%
  filter(variable == "lou",
         sex == "total",
         race %in% c("black", "total"),
         frl_status == "total",
         prior_setting %in% c("State Funded", "Head Start", "Child Care", "Home", "Other")) %>%
  mutate(prior_setting = if_else(prior_setting == "	State Funded", "State-Funded", prior_setting))

plt_by(kready_louisville,
       prior_setting,
       kready,
       school = T,
       title_text = "JCPS Kindergarten Readiness by Prior Setting",
       caption_text = "Source: Greater Louisville Project
                       Data from the Kentucky Department of Education School Report Card",
       remove_legend_title = T)

```

#### Prior setting by Race

The graph below shows the prior setting of students entering JCPS kindergarten in 2019. About 60% of students were enrolled in a child care program or preschool outside the home, and around 40% of students were at home with their parents or another caretaker.

Students who are White, Asian, American Indian or Alaska Native, or of two or more races are more likely than average to be enrolled in professional care setting outside of the home before entering JCPS. Students who are Black are much less likely to be enrolled in professional child care, but much more likely to be enrolled in State Funded preschool. Hispanic students and students whose race is not known are much more likely to be in a home setting.

```{r}
prior_setting_race <- readxl::read_excel("early-childhood/raw_data/ORR DRMS 9969 MetroUnitedWay.xlsx",
                                         sheet = "Race", skip = 1)

prior_setting_race %<>%
  pivot_longer(cols = `State Funded`:Other, names_to = "Prior Setting", values_to = "count") %>%
  filter(!is.na(count)) %>%
  group_by(Race) %>%
  mutate(
    percent = count / sum(count) * 100,
    count = scales::comma(count, accuracy = 1)) %>%
  ungroup() %>%
  mutate(
    Race = if_else(Race == "Grand Total", "All JCPS Students", Race),
    Race = if_else(Race == "White (Non-Hispanic)", "White", Race),
    Race = if_else(Race == "African American", "Black", Race),
    Race = factor(Race, levels = rev(c("All Students",
                                   "American Indian or Alaska Native",
                                   "Asian", 
                                   "Black",
                                   "Hispanic",
                                   "White",
                                   "Two or more races",
                                   "Unknown")),
                  ordered = TRUE),
    `Prior Setting` = factor(`Prior Setting`,
                             levels = rev(c("Child Care", "State Funded", "Head Start",
                                        "Other", "Home")),
                             ordered = TRUE))

plot_ly(prior_setting_race, x = ~percent, y = ~Race, 
        color = ~`Prior Setting`,
        colors = c("Child Care" = "#d63631",
                   "State Funded" = "#323844",
                   "Head Start" = "#eaab21",
                   "Other" = "#a7bfd7", 
                   "Home" = "#7CE3B6"),
        text = ~`count`,
        type = 'bar',
        hovertemplate = paste('Percent: %{x:.1f}%<br>Count: %{text}<extra></extra>')) %>%
  layout(
    title = "JCPS Prior Setting by Race",
    font = list(family = "Montserrat"),
    barmode = 'stack',
    yaxis = list(title = ""),
    xaxis = list(title = "Percent"),
    legend = list(title = list(text = "Prior Setting")))
```

####  Prior setting by Zip Code

Among children who enter JCPS, children in the Highlands and in Eastern Louisville are more likely than average to be enrolled in professional child care before entering JCPS. Children in West Louisville are most likely to be enrolled in State Funded preschool at JCPS, and children in South Louisville are most likely to be in a home setting.

```{r}
prior_setting_zip <- readxl::read_excel("early-childhood/raw_data/ORR DRMS 9969 MetroUnitedWay.xlsx", 
                                        sheet = "Zip Code", skip=1)

prior_setting_zip %<>%
  mutate(
    zip = `Zip Code`,
    total_students = `State Funded` + `Head Start` + `Child Care` + Home + Other) %>%
  mutate(across(`State Funded`:`Other`, ~ . / total_students * 100)) %>%
  filter(!is.na(zip)) 
  
prior_setting_map <- map_zip %>%
  left_join(prior_setting_zip, by = "zip")

pal <- colorNumeric("viridis", domain = c(0, 75))

leaflet(prior_setting_map) %>%
  addTiles() %>%
  addPolygons(
    color = "#444444", fillOpacity = 0.9, weight = 2, smoothFactor = 0.5,
    fillColor = ~pal(`Child Care`), group = "Child Care") %>%
  addPolygons(
    color = "#444444", fillOpacity = 0.9, weight = 2, smoothFactor = 0.5,
    fillColor = ~pal(`State Funded`), group = "State Funded") %>%
  addPolygons(
    color = "#444444", fillOpacity = 0.9, weight = 2, smoothFactor = 0.5,
    fillColor = ~pal(`Head Start`), group = "Head Start") %>%
  addPolygons(
    color = "#444444", fillOpacity = 0.9, weight = 2, smoothFactor = 0.5,
    fillColor = ~pal(`Home`), group = "Home") %>%
  addPolygons(
    color = "#444444", fillOpacity = 0.9, weight = 2, smoothFactor = 0.5,
    fillColor = ~pal(`Other`), group = "Other") %>%
 addLegend(pal = pal, values = c(0, 75), opacity = 0.7,
           title = "Percent") %>%
   addLayersControl(baseGroups = c("Child Care", "State Funded", "Head Start", "Home", "Other"),
                    options = layersControlOptions(collapsed = F))

```


### by Race and Prior setting

Combining the analysis by race and prior setting shows which settings are most effective at ensuring children enter kindergarten ready to learn. Click on the dropdown box on the right of the graph to toggle the prior setting.

Among the groups we examine here, the smallest racial disparities exist among children who were previously enrolled in Head Start or state-funded preschool. This is likely due to the fact that families must meet certain income limits to enroll their children in these programs, so children in these programs come from families with common economic situations. Black and Brown children in these settings enter kindergarten with relatively high readiness rates, and they have seen improvements since 2013-14.

Students in professional child care settings are the most kindergarten ready; however, racial disparities for these children are wider than for children in all other settings. As will be discussed later, this reflects differences in access to affordable and high-quality child care.

Differences in kindergarten readiness among children who were previously in a home setting with their parents (Home) or in another home-based setting (Other) are difficult to interpret because it reflects a wide variety of experiences for children. On average, children who were previously at home with their parents enter kindergarten the least ready to learn.

```{r kready_race_setting}
kready_race_plotly <- kready_ky %>%
  filter(variable == "lou",
         sex == "total",
         race %in% c("black", "white", "hispanic", "asian"),
         frl_status == "total",
         prior_setting %in% c("All Students", "State Funded", "Head Start", "Child Care", "Home", "Other")) %>%
  mutate(race = str_to_title(race)) %>%
  pivot_wider(names_from = race, values_from = kready) %>%
  mutate(year_label = paste0(year - 1, "-", year - 2000))

trnfm_list <- 
  list(
      list(
        type = 'filter',
        target = ~prior_setting,
        operation = 'in',
        value = unique(kready_race_plotly$prior_setting)[1]))

plot_ly(kready_race_plotly, width = "100%") %>%
  add_trace(x = ~year_label, y = ~Asian, name = "Asian", type = "scatter", mode = "lines", 
            line = list(color = '#a7bfd7', width = 2), 
            marker = list(color = '#a7bfd7', size = 6),
            transforms = trnfm_list) %>%
  add_trace(x = ~year_label, y = ~Black, name = "Black", type = "scatter", mode = "lines", 
            line = list(color = '#d63631', width = 2), 
            marker = list(color = '#d63631', size = 6),
            transforms = trnfm_list) %>%
  add_trace(x = ~year_label, y = ~Hispanic, name = "Hispanic", type = "scatter", mode = "lines", 
            line = list(color = '#eaab21', width = 2), 
            marker = list(color = '#eaab21', size = 6),
            transforms = trnfm_list) %>%
  add_trace(x = ~year_label, y = ~White, name = "White", type = "scatter", mode = "lines", 
            line = list(color = '#323844', width = 2), 
            marker = list(color = '#323844', size = 6),
            transforms = trnfm_list) %>%
  layout(title = "JCPS Kindergerten Readiness by Race",
         font = list(family = "Montserrat"),
         xaxis = list(title = "Year"),
         yaxis = list(title = "Percent Ready", range = c(0, 100)),
         hovermode = "x unified",
         updatemenus = list(
          list(
            x = 1.25,
            y = 0.75,
            buttons = list(
              list(method = "restyle",
                   args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[1]),
                   label = unique(kready_race_plotly$prior_setting)[1]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[2]),
                  label = unique(kready_race_plotly$prior_setting)[2]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[3]),
                  label = unique(kready_race_plotly$prior_setting)[3]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[4]),
                  label = unique(kready_race_plotly$prior_setting)[4]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[5]),
                  label = unique(kready_race_plotly$prior_setting)[5]),
                            list(method = "restyle",
                   args = list("transforms[0].value", unique(kready_race_plotly$prior_setting)[6]),
                   label = unique(kready_race_plotly$prior_setting)[6])))))

```

### by Geography 

#### Student Zip Code
This data was acquired through a data request to JCPS. Note that this data only includes parents who send their children to JCPS, so does not include children who attend private school or who are homeschooled.

The data show wide disparities in kindergarten readiness across Louisville. Because some zip codes contain small numbers of students, we combine data over three years to increase the reliability of the data. Kindergarten readiness by zip code ranges from 30% in 40118 to 81% in 40205.
```{r kindergarten_readiness_data}
# Kready math

# ready w/ enrichments * (% distinguished + % proficient)
ready_prof_dist_math = (643 * (.317 + .353) + 2956 * (.122 + .355)) / 
                    (643 * (1 - .143) + 2956 * (1 - .111)) * 100
not_ready_prof_dist_math = 3886 * (.034 + .160) / 3886 * (1 - .111) * 100

mult_math = ready_prof_dist_math / not_ready_prof_dist_math

# Kready reading
ready_prof_dist_reading = (643 * (.463 + .235) + 2956 * (.219 + .309)) / 
                    (643 * (1 - .143) + 2956 * (1 - .111)) * 100
not_ready_prof_dist_reading = 3886 * (.057 + .165) / 3886 * (1 - .111) * 100

mult_reading = ready_prof_dist_reading / not_ready_prof_dist_reading

# black children
# ready w/ enrichments * (% distinguished + % proficient)
ready_prof_dist_math = (149 * (.148 + .376) + 940 * (.044 + .234)) / 
                    (149 * (1 - .067) + 940 * (1 - .089)) * 100
not_ready_prof_dist_math = 1443 * (.013 + .089) / 1443 * (1 - .090) * 100

mult_math_black = ready_prof_dist_math / not_ready_prof_dist_math

# Kready reading
ready_prof_dist_reading = (149 * (.275 + .248) + 940 * (.091 + .240)) / 
                    (149 * (1 - .067) + 940 * (1 - .089)) * 100
not_ready_prof_dist_reading = 1443 * (.019 + .106) / 1443 * (1 - .090) * 100

mult_reading_black = ready_prof_dist_reading / not_ready_prof_dist_reading

race_math = mult_math_black / mult_math
race_reading = mult_reading_black / mult_reading


# Ready in kready data
kready_zip <- readxl::read_excel("early-childhood/raw_data/Copy of 1920_Brigance Zip Code_Prior Settings TablesForORR.xlsx",
                                 sheet = "ZipCode3Years", 
                                 range ="B4:K38",
                                 col_names = c("zip", paste0(c("num_", "ready_", "notready_"),
                                                             rep(2018:2020, each = 3))),
                                 col_types = c("text", rep("numeric", 9)),
                                 na = "*")

# Clean and organize data frame
kready_zip %<>% 
  pivot_longer(num_2018:notready_2020, names_to = c("var_type", "year"), names_sep = "_") %>%
  filter(var_type != "notready") %>%
  mutate(
    var_type = case_when(var_type == "num" ~ "population",
                         var_type == "ready" ~ "percent")) %>%
  transmute(
    zip, year, var_type, 
    kready = if_else(var_type == "percent", value * 100, value))

# Summarize data frame over three years due to unstable data
kready_zip_sum <- kready_zip %>%
  pivot_wider(names_from = var_type, values_from = kready) %>%
  group_by(zip) %>%
  filter(all(!is.na(percent))) %>%
  summarise(
    percent = weighted.mean(percent, population),
    population = sum(population),
    .groups = "drop") %>%
  rename(kready = percent)

# Join data to map
map_zip %<>% left_join(kready_zip_sum, by = "zip")
  
ggplot(map_zip) + 
  geom_sf(aes(fill = kready), color = "white") +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  viridis::scale_fill_viridis(na.value = "grey", 
                            name = "Percent Ready") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = "JCPS Kindergarden Readiness by Student's Home Zip Code",
       subtitle = "Average for the school years 2017-2018, 2018-2019, and 2019-2020",
       caption_text = "Source: Greater Louisville Project
                       Data from JCPS") +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```

#### School Location {.panelset}

##### Elementary School Assignment Area

This map shows kindergarten readiness results by school. The areas on the map represent student assignment areas for individual schools, and the thicker white lines show student assignment clusters.
```{r clean_data}
load("early-childhood/raw_data/kready_jc.RData")
load("early-childhood/raw_data/map_elementary.RData")

# Filter out 
kready_jc_subset <- kready_jc %>%
  filter(code != "275", 
         year == 2020, 
         demographic == "All Students",
         prior_setting == "All Students") %>%
  mutate(code = str_sub(code, 4, 6) %>%
                as.numeric)

map_elementary %<>%
  rename(
    SCHOOL_NAME = SCHOOL_NAM,
    LOCATION = LocNumber,
    CLUSTER = ClusterNum)

map_elementary %<>%
  left_join(kready_jc_subset, by = c("LOCATION" = "code"))

map_cluster <- map_elementary %>%
  group_by(CLUSTER) %>%
  summarise(
    kready = weighted.mean(kready, num_students),
    .groups = "drop")

ggplot(map_elementary) + 
  geom_sf(aes(fill = kready), color = "white") +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  viridis::scale_fill_viridis(na.value = "grey", 
                            name = "Percent Ready") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = "JCPS Kindergarden Readiness by School Location, 2019-2020",
       caption_text = "Source: Greater Louisville Project
                       Data from the Kentucky Department of Education School Report Card") +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA)) + 
  geom_sf(data = map_cluster, fill=NA, color = "white", size = 1)
```

##### Elementary School Cluster
This map shows kindergarten readiness results by elementary school clusters.
```{r}
ggplot(map_cluster) + 
  geom_sf(aes(fill = kready), color = "white", size = 1) +
  #scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  viridis::scale_fill_viridis(na.value = "grey", 
                            name = "Percent Ready") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = "JCPS Kindergarden Readiness by School Cluster, 2019-2020",
       caption_text = "Source: Greater Louisville Project
                       Data from the Kentucky Department of Education School Report Card") +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```

## Early Child Care

High quality, affordable, and accessible child care is important for our community. As discussed in the prior setting section above, children in a professional child care setting enter kindergarten with the highest levels of kindergarten readiness. Additionally, reliable child care is important to ensure that caretakers are able to work. However, child care is not affordable or accessible for many families.

Using data from [kynect](https://kynect.ky.gov/benefits/s/child-care-provider?language=en_US), we examine the cost and availability of child care using information from child care providers. While providers should update their information anytime it changes, some data is not current, and many child care centers are in flux due to COVID-19. However, the kynect database is linked to the state registration system, and it is the most comprehensive source available at this time.

While our data examines the total licensed capacity of child care providers, the number of available child care slots is smaller. Many providers have smaller actual capacity to maintain quality standards, due to issues retaining staff, or due to temporary barriers due to COVID-19.

### Cost

The median cost of child care for one toddler is \$8,710 per year, approximately 15% of the median family income for Jefferson County in 2019. We report daily rates in the charts below because that is the format provided by kynect. The median annual rate of \$8,710 corresponds to a daily rate of $33.50.

#### Comparison to CCAP

The chart below shows the cost of child care by age group and provider type. The "CCAP Reimbursement Cap" column lists maximum reimbursement rates for the Kentucky's Child Care Assistance Program, and the column "Percent of Slots under CCAP" shows the percent of slots that would be fully paid for by CCAP.

```{r child_care_provider_data}
# Creates four data frames linked by license number (CLR)

# provider_information: original file from the state.
#    includes provider name, address, and several other fields.

# provider_hours: includes open days and hours

# provider_cost: includes program offerings and cost

# provider_service_offerings: includes which age ranges are available

# provider_other: includes other available info. 
#    Might just duplicate fields from program_information, though.

# Infant: <12 months
# Toddler: between 12 and 24 months
# School-age: child enrolled in kindergarten, elementary, or secondary education

# Read in provider information (county, name, address, etc.)
provider_information <- readxl::read_xlsx("early-childhood/raw_data/Chilcare Provider Download.xlsx",
                                          skip = 2)

# Subset to Jefferson County and rename license column for ease of use

provider_information %<>% 
  filter(County == "JEFFERSON") %>%
  rename(CLR = `CLR#`) %>%
  filter(CLR != "C6739") %>%
  transmute(
    CLR,
    Name,
    Location = `Location Address`,
    Capacity,
    Transportation = if_else(`Transportation Service` == "Y", T, F),
    STARS = as.numeric(`Stars Rating`),
    Type = `Provider Type`,
    active_CCAP = if_else(`Active CCAP Children` == "Y", T, F),
    special_needs = case_when(
      `Serves Children with Special Needs` == "Y" ~ T,
      `Serves Children with Special Needs` == "N" ~ F,
      TRUE ~ NA),
    
    offerring = recode(`Age Range Of Service`,
                      "Infant" = 1,
                      "Infant To School Age" = 2,
                      "Infant To Two_To_School" = 3,
                      "Toddler To Two_To_School" = 4,
                      "Toddler To School_Age" = 5,
                      "Two_To_School" = 6,
                      "Two_To_School To School_Age" = 7,
                      "School_Age" = 8,
                      "No Information Available" = 9),
    
    Infant    = if_else(offerring %in% 1:3, T, F),
    Toddler   = if_else(offerring %in% 2:5, T, F),
    Preschool = if_else(offerring %in% 2:7, T, F),
    School    = if_else(offerring %in% c(2, 5, 7, 8), T, F)) %>%
  mutate(across(Infant:School, ~ if_else(offerring == 9, NA, .))) %>%
  select(-offerring)
    
# Read in provider data collected from KYnect 
provider_data <- read_csv("early-childhood/raw_data/Childcare Provider Cost Data.csv",
                          col_names = c("CLR", "Day", "Time", "Services", "FullTime", "PartTime", "Other"))

# Check that no data is missing a license number - PASSED
# missing_CLR <- provider_data %>%
#   filter(is.na(CLR)) %>%
#   filter(!is.na(Day) | !is.na(Time) | !is.na(Services) |
#            !is.na(FullTime) | !is.na(PartTime) | !is.na(Other))
# 
# # Check that the list of license numbers are identical - PASSED
# check_data1 <- mean(provider_information$CLR %in% provider_data$CLR) + 
#                mean(provider_data$CLR %in% provider_information$CLR)

# Check values and number of each variable
# table(provider_data$Day) # good, 1 provider removed from listing
# table(provider_data$Time) # good
# table(provider_data$Services) # good
# table(provider_data$FullTime) # good
# table(test$PartTime) # often contains data for "Other"
# table(provider_data$Other) # good
# table(str_remove(provider_data$Other, "\\d*")) # good

# Filter out rows without license numbers (used to make data entry easier)
# Remove C6739, which closed between the creation of the provider registry and data collection 
# Remove L355501, which is actually in Goshen
provider_data %<>%
  filter(!is.na(CLR), 
         CLR %not_in% c("C6739", "L355501"))

# The data for the "Other" column is often located in the PartTime column.
# Group by license and determine whether the number of children is in the PartTime column. (should be in Other)
# If so, move the data from the PartTime column to the Other column for that provider.
provider_data %<>%
  group_by(CLR) %>%
  mutate(move_PartTime = if_else(any(str_detect(PartTime, "Children")), T, F),
         move_PartTime = if_else(is.na(move_PartTime), F, move_PartTime)) %>%
  mutate(Other = if_else(move_PartTime, PartTime, Other),
         PartTime = if_else(move_PartTime, NA_character_, PartTime)) %>%
  ungroup() %>%
  select(-move_PartTime)

# Hours data
# Clean by filtering data to days of the week
# Convert hour text to numbers
provider_hours <- provider_data %>%
  select(CLR, Day, Time) %>%
  filter(Day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")) %>%
  mutate(
    open_hour     = as.numeric(str_extract(Time, "^\\d{1,2}")),
    open_minutes  = as.numeric(str_extract(Time, "(?<=:)\\d*")),
    open_period   = str_extract(Time, ".{2}(?= -)"),
    close_hour    = as.numeric(str_extract(Time, "(?<=- )\\d{1,2}")),
    close_minutes = as.numeric(str_extract(Time, "(?<=- .{1,2}:)\\d{1,2}")),
    close_period  = str_extract(Time, ".{2}$"),
    
    open_hour  = if_else(open_hour  == 12, 0, open_hour),
    close_hour = if_else(close_hour == 12, 0, close_hour),
    
    open_time = open_hour + open_minutes / 60 + if_else(open_period == "PM", 12, 0),
    close_time = close_hour + close_minutes / 60 + if_else(close_period == "PM", 12, 0)) %>%
  select(CLR, Day, Hours = Time, open_time, close_time)

# Cost data
# Multiple offerings for each age-group are labeled with numbers (e.g. Toddler 1, Toddler 2). Remove.
# Clean by filtering data to type of service (infant, toddler, preschool, school age)
# Average multiple offerings for the same provider and age group
provider_cost <- provider_data %>%
  select(CLR, Services, FullTime, PartTime) %>%
  mutate(
    Services = str_remove(Services, " \\d"),
    FullTime = as.numeric(FullTime),
    PartTime = as.numeric(PartTime)) %>%
  filter(Services %in% c("Infant", "Toddler", "Preschool", "School Age")) %>%
  group_by(CLR, Services) %>%
  summarise(
    FullTime = mean(FullTime),
    PartTime = mean(PartTime)) %>%
  ungroup()

# View number of different-cost options within each age group
# provider_cost %>% group_by(CLR, Services) %>% summarise(n = n()) %>% pull(n) %>% table()

# Other data
provider_other <- provider_data %>%
  select(CLR, Other)

# Column contains data labels/headers followed by data
# Copy the data to a new column and shift it up one row to create key-value pairs 
provider_other$header <- provider_other$Other
provider_other$data <- c(provider_other$Other[2:nrow(provider_other)], NA_character_)

# Filter the data to rows where the header is in the header column. (Remove value-key pairs.)
# Spread the data across columns
provider_other %<>%
  select(-Other) %>%
  filter(header %in% c("Capacity", "CCCAP Subsidy", "Acceditations", "Food Permit", "Transportation")) %>%
  pivot_wider(names_from = header, values_from = data) %>%
  transmute(
    CLR,
    Capacity = as.numeric(str_remove(Capacity, " Children")),
    accepts_CCCAP = case_when(`CCCAP Subsidy` == "Accepted" ~ T,
                              `CCCAP Subsidy` == "No" ~ F,
                              TRUE ~ NA),
    food_permit = case_when(`Food Permit` == "Yes" ~ T,
                            `Food Permit` == "No" ~ F,
                            TRUE ~ NA),
    transportation = if_else(Transportation == "Yes", T, F)) %>%
  select(CLR,
         accepts_CCAP = accepts_CCCAP,
         food_permit)

provider_information %<>%
  left_join(provider_other, by = "CLR")

# provider_information: original file from the state.
#    includes provider name, address, and several other fields.

# provider_hours: includes open days and hours

# provider_cost: includes program offerings and cost

# provider_service_offerings: includes which age ranges are available

# provider_other: includes other available info. 
#    Might just duplicate fields from program_information, though.

  
# Determine offerings for each provider based on the cost data
provider_offerings_cost <- provider_data %>%
  filter(!is.na(Services)) %>%
  group_by(CLR) %>%
  summarise(
    Infant = if_else(any(str_detect(Services, "Infant")), T, F),
    Toddler = if_else(any(str_detect(Services, "Toddler")), T, F),
    Preschool = if_else(any(str_detect(Services, "Preschool")), T, F),
    School = if_else(any(str_detect(Services, "School Age")), T, F),
    .groups = "drop") %>%
  mutate(all_missing = if_else(!Infant & !Toddler & !Preschool & !School, T, F)) %>%
  mutate(across(Infant:School, ~if_else(all_missing, NA, .))) %>%
  select(-all_missing) %>%
  rename(Infant_from_cost = Infant,
         Toddler_from_cost = Toddler,
         Preschool_from_cost = Preschool,
         School_from_cost = School)

# Determine offerings for each provider based on the general information
provider_offerings_info <- provider_information %>%
  rename(Infant_from_info = Infant,
         Toddler_from_info = Toddler,
         Preschool_from_info = Preschool,
         School_from_info = School)

# Combine offering info from cost and general info, prefer cost data
provider_offerings <- provider_offerings_info %>%
  left_join(provider_offerings_cost, by = "CLR") %>%
  mutate(check = (Infant_from_info == Infant_from_cost &
                  Toddler_from_info == Toddler_from_cost &
                  Preschool_from_info == Preschool_from_cost &
                  School_from_info == School_from_cost)) %>%
  mutate(Infant    = if_else(!is.na(Infant_from_cost), Infant_from_cost, Infant_from_info),
         Toddler   = if_else(!is.na(Toddler_from_cost), Toddler_from_cost, Toddler_from_info),
         Preschool = if_else(!is.na(Preschool_from_cost), Preschool_from_cost, Preschool_from_info),
         School    = if_else(!is.na(School_from_cost), School_from_cost, School_from_info)) %>%
  select(CLR, Infant, Toddler, Preschool, School)
  # Missing values are for certified providers
  # Most certified providers offer all age ranges
  # Fill in missings with all age ranges

provider_offerings[with(provider_offerings, is.na(Infant) & is.na(Toddler) & is.na(Preschool) & is.na(School)), c("Infant", "Toddler", "Preschool", "School")][] <- T

provider_information %<>%
  select(-Infant, -Toddler, -Preschool, -School) %>%
  left_join(provider_offerings, by = "CLR")

rm(provider_data, provider_offerings_cost, provider_offerings_info)


# Cost summary
provider_cost_summary <- provider_cost %>%
  left_join(provider_information, by = "CLR") %>%
  group_by(Services) %>%
  summarize(
    mean = weighted.mean(FullTime, Capacity, na.rm = TRUE),
    median = unname(Hmisc::wtd.quantile(FullTime, Capacity, probs = 0.5, na.rm = TRUE)),
    sd = sqrt(Hmisc::wtd.var(FullTime, Capacity, na.rm = TRUE)),
    min = min(FullTime, na.rm = TRUE),
    max = max(FullTime, na.rm = TRUE))

# Infant (0-1): 13.2, Toddler (1-2): 24.7, 
# Preschool (2-4): 69.4,
# School-age (5-6): 30,

# Infant (0-1): 15.9, Toddler (1-2): 29.8, 
# Preschool (2-4): 60,
# School-age (5-8): 24.3, (9-11): 11.1, (12-14): 4.6
# https://www2.census.gov/library/publications/2013/demo/p70-135.pdf

# 4-year old (per kready data) .630

pop_df <- read_tsv("early-childhood/raw_data/Bridged-Race Population Estimates 1990-2019.txt")

pop_df %<>%
  filter(is.na(Notes)) %>%
  transmute(
    age = as.numeric(`Age Code`),
    population = Population) %>%
  filter(age <= 14)

childcare_participation <- data.frame(
  age = c(0:14),
  type = c("Infant", "Toddler", 
           rep("Preschool", 3),
           rep("School", 10)),
  participation = c(.159, # infant 0
                    rep(.298, 2), # toddler 1, 2
                    .39, # preschool  3
                    .63, # preschool  4
                    rep(.243, 4), # school age 5 - 8,
                    rep(.111, 3), # school age 9 - 11,
                    rep(.046, 3))) # School age 12 - 14

childcare_participation %<>%
  left_join(pop_df, by = "age") %>%
  mutate(est_enrolled = participation * population)

childcare_participation_pct <- childcare_participation %>%
  group_by(type) %>%
  summarise(est_enrolled = sum(est_enrolled), .groups = "drop") %>%
  mutate(est_pct = est_enrolled / sum(est_enrolled))

temp_infant <- provider_information %>%
  filter(Infant) %>%
  summarise(Capacity = sum(Capacity)) %>%
  pull(Capacity)

temp_toddler <- provider_information %>%
  filter(Toddler) %>%
  summarise(Capacity = sum(Capacity)) %>%
  pull(Capacity)

temp_preschool <- provider_information %>%
  filter(Preschool) %>%
  summarise(Capacity = sum(Capacity)) %>%
  pull(Capacity)

temp_school <- provider_information %>%
  filter(School) %>%
  summarise(Capacity = sum(Capacity)) %>%
  pull(Capacity)


provider_seat_estimate <- provider_information %>%
  select(CLR, Capacity, Infant, Toddler, Preschool, School) %>%
  pivot_longer(Infant:School, names_to = "type", values_to = "includes") %>%
  group_by(CLR) %>%
  mutate(num_oferrings = sum(includes)) %>%
  ungroup() %>%
  mutate(Capacity = Capacity / num_oferrings) %>%
  group_by(type) %>%
  summarise(Capacity = sum(Capacity))
  
# Some care centers seem to have reported weekly rates. That throws the mean and sd off, but shouldn't really impact the medians. Median cost is $30 per day for infants and toddlers, down to $25 per day for school age children.

# 150 a week or 7800 a year, or an average of $650 a month.

ccapcap <- data.frame(
  Services = rep(c("Infant", "Toddler", "Preschool", "School Age"),
                 2),
  Type = rep(c("Certified", "Licensed"), each = 4),
  ft_cap = c(25, 25, 24, 20, 27, 27, 25, 22),
  pt_cap = c(18, 18, 17, 14, 19, 19, 18, 15))

provider_cost_summary <- provider_cost %>%
  left_join(provider_information, by = "CLR") %>%
  left_join(ccapcap, by = c("Services", "Type")) %>%
  group_by(Services, Type) %>%
  summarize(
    ft_mean = weighted.mean(FullTime, Capacity, na.rm = TRUE),
    ft_median = unname(Hmisc::wtd.quantile(FullTime, Capacity, probs = 0.5, na.rm = TRUE)),
    ft_sd = sqrt(Hmisc::wtd.var(FullTime, Capacity, na.rm = TRUE)),
    ft_min = min(FullTime, na.rm = TRUE),
    ft_max = max(FullTime, na.rm = TRUE),
    ft_under_ccap = sum(Capacity[FullTime <= ft_cap], na.rm=T) / sum(Capacity),
    pt_mean = weighted.mean(PartTime, Capacity, na.rm = TRUE),
    pt_median = unname(Hmisc::wtd.quantile(PartTime, Capacity, probs = 0.5, na.rm = TRUE)),
    pt_sd = sqrt(Hmisc::wtd.var(PartTime, Capacity, na.rm = TRUE)),
    pt_min = min(PartTime, na.rm = TRUE),
    pt_max = max(PartTime, na.rm = TRUE),
    pt_under_ccap = sum(Capacity[PartTime <= pt_cap], na.rm=T) / sum(Capacity),
    n = n(),
    ft_cap = mean(ft_cap),
    pt_cap = mean(pt_cap))

provider_cost_summary_collapsed <- provider_cost %>%
  left_join(provider_information, by = "CLR") %>%
  left_join(ccapcap, by = c("Services", "Type")) %>%
  group_by(Services) %>%
  summarize(
    Type = "Total",
    ft_mean = weighted.mean(FullTime, Capacity, na.rm = TRUE),
    ft_median = unname(Hmisc::wtd.quantile(FullTime, Capacity, probs = 0.5, na.rm = TRUE)),
    ft_sd = sqrt(Hmisc::wtd.var(FullTime, Capacity, na.rm = TRUE)),
    ft_min = min(FullTime, na.rm = TRUE),
    ft_max = max(FullTime, na.rm = TRUE),
    ft_under_ccap = sum(Capacity[FullTime <= ft_cap], na.rm=T) / sum(Capacity),
    pt_mean = weighted.mean(PartTime, Capacity, na.rm = TRUE),
    pt_median = unname(Hmisc::wtd.quantile(PartTime, Capacity, probs = 0.5, na.rm = TRUE)),
    pt_sd = sqrt(Hmisc::wtd.var(PartTime, Capacity, na.rm = TRUE)),
    pt_min = min(PartTime, na.rm = TRUE),
    pt_max = max(PartTime, na.rm = TRUE),
    pt_under_ccap = sum(Capacity[PartTime <= pt_cap], na.rm=T) / sum(Capacity),
    n = n(),
    ft_cap = mean(ft_cap),
    pt_cap = mean(pt_cap)) %>%
  mutate(ft_cap = NA_real_, pt_cap = NA_real_)
  
provider_cost_summary %>%
  #bind_rows(provider_cost_summary_collapsed) %>%
  select(Type, Services, n, ft_median, ft_under_ccap,
         pt_median, pt_under_ccap, ft_cap, pt_cap) %>%
  gt() %>%
  tab_header(title = "Cost of Child Care compared to CCAP Reimbursement Rates",
             subtitle = "") %>%
  fmt_currency(columns = vars(ft_median, pt_median, ft_cap, pt_cap),
               use_subunits = F) %>%
  fmt_percent(columns = vars(ft_under_ccap, pt_under_ccap),
              decimals = 0) %>%
  cols_label(n = "Number of Providers",
             ft_median = "Median Daily Price", 
             ft_cap = "CCAP Reimbursement Cap",
             ft_under_ccap = "Slots at or below CCAP Rate", 
             pt_median = "Median Daily Price", 
             pt_cap = "CCAP Reimbursement Cap",
             pt_under_ccap = "Slots at or below CCAP Rate") %>%
  row_group_order(
      groups = c("Infant", "Toddler", "Preschool", "School Age")) %>%
  tab_spanner(
    label = "Full-Time",
    columns = vars(ft_median, ft_cap, ft_under_ccap)) %>%
  tab_spanner(
    label = "Part-Time",
    columns = vars(pt_median, pt_cap, pt_under_ccap)) %>%
  cols_align(align = "center") %>%
    tab_source_note(
    source_note = md("Source: Greater Louisville Project. Data from kynect.")) %>%
  opt_row_striping(row_striping = TRUE) %>%
  opt_table_outline() %>%
  tab_options(
    table.font.size = px(12),
    table.width = pct(50)) %>%
  tab_style(
    cell_text(
      font = "Montserrat",
      weight = "bold"), 
    cells_row_groups()) %>%
  fmt_missing(c("ft_cap", "pt_cap"), missing_text = "-")
```

#### Full-Time Care

The chart below shows the estimated number of full-time child care slots by daily price in Louisville.

Based on kynect data, the total number of licensed child care slots for children of all ages is 31,597. Most of these slots are licensed to be available children of all age ranges, but we estimate the actual utilization of child care slots by age group based on data from the Survey of Income and Program Participation. For example, the number of licensed slots available for infants is over 20,000, however the vast majority of those slots are used by children of other ages for whom they are also licensed.

```{r provider_cost}
provider_information %<>%
  mutate(cum_pct = 
           if_else(Infant, 0.05022589, 0) +
           if_else(Toddler, 0.09359373, 0) +
           if_else(Preschool, 0.41347562, 0) +
           if_else(School, 0.44270477, 0),
         infant_est = if_else(Infant, Capacity * 0.05022589 / cum_pct, 0),
         toddler_est = if_else(Toddler, Capacity * 0.09359373 / cum_pct, 0),
         preschool_est = if_else(Preschool, Capacity * 0.41347562 / cum_pct, 0),
         school_est = if_else(School, Capacity * 0.44270477 / cum_pct, 0))
         
temp_infant <- provider_information %>%
  filter(Infant) %>%
  mutate(Services = "Infant") %>%
  left_join(provider_cost, by = c("CLR", "Services")) %>%
  mutate(FullTime = if_else(FullTime > 5 * min(FullTime, na.rm = TRUE), FullTime / 5, FullTime)) %>%
  arrange(FullTime) %>%
  mutate(ft_cumsum = round(cumsum(infant_est), 0)) %>%
  arrange(PartTime) %>%
  mutate(pt_cumsum = round(cumsum(infant_est), 0))

temp_toddler <- provider_information %>%
  filter(Toddler) %>%
  mutate(Services = "Toddler") %>%
  left_join(provider_cost, by = c("CLR", "Services")) %>%
  mutate(FullTime = if_else(FullTime > 5 * min(FullTime, na.rm = TRUE), FullTime / 5, FullTime)) %>%
  arrange(FullTime) %>%
  mutate(ft_cumsum = round(cumsum(toddler_est), 0)) %>%
  arrange(PartTime) %>%
  mutate(pt_cumsum = round(cumsum(toddler_est), 0))

temp_preschool <- provider_information %>%
  filter(Preschool) %>%
  mutate(Services = "Preschool") %>%
  left_join(provider_cost, by = c("CLR", "Services")) %>%
  mutate(
    FullTime = if_else(FullTime > 5 * min(FullTime, na.rm = TRUE), FullTime / 5, FullTime),
    PartTime = if_else(PartTime > 5 * min(PartTime, na.rm = TRUE), PartTime / 5, PartTime)) %>%
  arrange(FullTime) %>%
  mutate(ft_cumsum = round(cumsum(preschool_est), 0)) %>%
  arrange(PartTime) %>%
  mutate(pt_cumsum = round(cumsum(preschool_est), 0))

temp_school <- provider_information %>%
  filter(School) %>%
  mutate(Services = "School Age") %>%
  left_join(provider_cost, by = c("CLR", "Services")) %>%
  mutate(
    FullTime = if_else(FullTime > 10 * min(FullTime, na.rm = TRUE), FullTime / 5, FullTime),
    PartTime = if_else(PartTime > 80, PartTime / 5, PartTime)) %>%
  arrange(FullTime) %>%
  mutate(ft_cumsum = round(cumsum(school_est), 0)) %>%
  arrange(PartTime) %>%
  mutate(pt_cumsum = round(cumsum(school_est), 0))

cost_seats <- bind_rows(temp_infant, temp_toddler, temp_preschool, temp_school)

cost_seats_ft <- cost_seats %>%
  arrange(ft_cumsum)

trnfm_list <- 
  list(
      list(
        type = 'filter',
        target = ~Services,
        operation = 'in',
        value = unique(cost_seats$Services)[1]))

plot_ly(filter(cost_seats_ft ,!is.na(FullTime))) %>%
  add_trace(x = ~ft_cumsum, y = ~FullTime, 
            type = "scatter", mode = "lines", 
            marker = list(color = '#d63631', size = 4),
            line = list(color = '#323844', width = 2),
            transforms = trnfm_list,
            hovertemplate = 
              paste('Price: $%{y:.2f} per day<br>Slots at or below price: %{x}<extra></extra>')) %>%
  layout(
    font = list(family = "Montserrat"),
    
    title = "Estimated Child Care Provider Slots by Price",
    
    xaxis = list(title = "Child Care Slots"),
    yaxis = list(title = "Daily Rate ($)", rangemode = "tozero"),
    showlegend = FALSE,
    updatemenus = list(
      list(
        x = 0.75,
        y = 0.85,
        
        buttons = list(
              list(method = "restyle",
                   args = list("transforms[0].value", unique(cost_seats$Services)[1]),
                   label = unique(cost_seats$Services)[1]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[2]),
                  label = unique(cost_seats$Services)[2]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[3]),
                  label = unique(cost_seats$Services)[3]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[4]),
                  label = unique(cost_seats$Services)[4])))))

```

#### Part-Time Care

The chart below shows the estimated number of part-time child care slots by daily price in Louisville.

Based on kynect data, the total number of licensed child care slots for children of all ages is 31,597. Most of these slots are licensed to be available children of all age ranges, but we estimate the actual utilization of child care slots by age group based on data from the Survey of Income and Program Participation. For example, the number of licensed slots available for infants is over 20,000, however the vast majority of those slots are used by children of other ages for whom they are also licensed.
```{r}
plot_ly(filter(cost_seats ,!is.na(PartTime))) %>%
  add_trace(x = ~pt_cumsum, y = ~PartTime, 
            type = "scatter", mode = "lines", 
            marker = list(color = '#d63631', size = 4),
            line = list(color = '#323844', width = 2),
            transforms = trnfm_list,
            hovertemplate = 
              paste('Price: $%{y:.2f} per half-day<br>Slots at or below price: %{x}<extra></extra>')) %>%
  layout(
    font = list(family = "Montserrat"),
    
    title = "Estimated Child Care Provider Slots by Price",
    
    xaxis = list(title = "Child Care Slots"),
    yaxis = list(title = "Daily Rate ($)", rangemode = "tozero"),
    showlegend = FALSE,
    updatemenus = list(
      list(
        x = 0.75,
        y = 0.85,
        
        buttons = list(
              list(method = "restyle",
                   args = list("transforms[0].value", unique(cost_seats$Services)[1]),
                   label = unique(cost_seats$Services)[1]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[2]),
                  label = unique(cost_seats$Services)[2]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[3]),
                  label = unique(cost_seats$Services)[3]),
              list(method = "restyle",
                  args = list("transforms[0].value", unique(cost_seats$Services)[4]),
                  label = unique(cost_seats$Services)[4])))))
```

```{r geocode_providers, eval=FALSE}
# Geocode providers

# Break information into individual pieces for best results
provider_information_addressed <- provider_information %>%
  mutate(
    street = str_extract(Location, ".*?(?=,)"),
    city = str_extract(Location, "(?<=, )\\w*(?=, KY)"),
    county = "Jefferson",
    state = "KY",
    postalcode = str_sub(Location, -5))

# Use free default providers first (Census and OSM)
pi_cascade <- provider_information_addressed %>%
  geocode(
    street = street,
    city = city,
    state = state,
    postalcode = postalcode,
    method = "cascade")

# Fill in missings with Geocodio (free up to 2,500 per day)

Sys.setenv(GEOCODIO_API_KEY = "cccff3c3cc3aca633fc09ccc3901c1a861a9069")
#pw: "glpgeocoder21!"

pi_fails <- pi_cascade %>%
  filter(is.na(lat)) %>%
  select(-lat, -long, -geo_method)

pi_fails %<>%
  geocode(
    street = street,
    city = city,
    state = state,
    postalcode = postalcode,
    method = "geocodio") %>%
  mutate(geo_method = "geocodio")

pi_fails %<>%
  mutate(geo_method = "geocodio")

pi_cascade %<>% 
  filter(!is.na(lat)) %>%
  bind_rows(pi_fails)

pi_cascade %<>% filter(CLR != "L355501")

save(pi_cascade, file = "raw_data/provider_locations.RData")
```

### Location

#### Provider map

The map below shows the location of the 395 licensed child care providers throughout the city. Hover over the map to see provider information.

The size of the circle indicates the number of licensed slots, and the color of the circle indicates the provider's [Kentucky All STARS quality rating](https://chfs.ky.gov/agencies/dcbs/dcc/Pages/kyallstars.aspx) based on family engagement, classroom quality, and staff qualifications. Level 1 is the default level indicating the provider is in good standing, and providers can choose to be evaluated to potentially earn a higher rating. The data does not distinguish between providers who have gone unrated and providers who earned a  level 1 rating. Providers might not feel the need to confirm their quality with a state evaluation.. However, providers at levels 2 and above have been evaluated and certified to meet certain standards.

Providers of all ratings can be found throughout the city. Looking at the distribution of quality ratings by neighborhood, there are no discernible trends. A larger issue is the general access to quality care: there are only three 5-STAR providers in Louisville, and only 107 out of 395 providers have more than one star.
```{r provider_map}
load("early-childhood/raw_data/provider_locations.RData")

provider_map <- st_as_sf(pi_cascade,
                         coords = c("long", "lat"), 
                         crs = 4326)

pi_cascade %<>%
  mutate(
    offerings = paste0(
      if_else(Infant, "Infant, ", ""),
      if_else(Toddler, "Toddler, ", ""),
      if_else(Preschool, "Preschool, ", ""),
      if_else(School, "School-age", "")),
    
    offerings = str_remove(offerings, ", $"),
    
    line1 = Name,
    line2 = paste0("Capacity: ", Capacity),
    line3 = paste0("Age range: ",  offerings)
  )

provider_labels <- 
  sprintf("%s<br/>%s<br/>%s",
          pi_cascade$line1,
          pi_cascade$line2,
          pi_cascade$line3) %>%
        lapply(htmltools::HTML)

pi_cascade %<>%
  mutate(
    type_color = if_else(Type == "Licensed", "blue", "red"),
    stars_color = viridis(5)[STARS])

leaflet(pi_cascade) %>%
  addTiles() %>%
  addCircleMarkers(lng = ~long, lat = ~lat,
                   radius = ~sqrt(Capacity),
                   color = ~stars_color,
                   label = provider_labels,
                   opacity = 0.7,
                   weight = 2,
                   labelOptions = labelOptions(style = 
                    list("font-weight" = "normal", 
                         "font-family" = "Montserrat", 
                         padding = "3px 8px"),
                    textsize = "15px",
                    direction = "auto")) %>%
  addPolygons(data = st_transform(filter(map_county, FIPS == "21111"), 4326),
              fill = F, weight = 2, color = "black") %>%
  addLegend(title = "STARS rating", labels = 1:5, colors = viridis(5))

```

#### Providers by Neighborhood
Unlike STAR ratings, there are patterns in terms of the distribution of child care slots throughout Louisville. The map below shows the number of child care slots available to children ages 0 to 4 by neighborhood. The highest availability is located around Downtown, Old Louisville, and the University of Louisville. This likely reflects the large number of people who commute to work in this area and use nearby child care. These neighborhoods are the only ones where there are more slots available than children who live there.

The lowest availability of child care is in neighborhoods at the very Southwest and West of the city: Fairdale and Valley Station in the South Louisville, and Chickasaw, Shawnee, and Portland in West Louisville.

```{r providers_by_nh}
map_nh <- st_transform(map_nh, 4326)

provider_nh <- st_join(provider_map, map_nh, join = st_within)

provider_nh %<>% 
  group_by(neighborhood) %>%
  summarise(seats = sum(infant_est + toddler_est + preschool_est))

child_pop <- poverty_nh %>%
  filter(year == max(year),
         sex == "total",
         race %in% c("total", "white"),
         var_type == "population") %>%
  select(neighborhood, race, poverty_under_5) %>%
  pivot_wider(names_from = "race", values_from = "poverty_under_5") %>%
  mutate(
    percent_nonwhite = (total - white) / total * 100)

provider_nh_summary <- provider_nh %>%
  st_drop_geometry() %>%
  left_join(child_pop, by = "neighborhood") %>%
  mutate(seats_per = seats / total) %>%
  transmute(
    Neighborhood = neighborhood,
    `Estimated Seats` = seats,
    `Seats per child` = seats_per,
    `Percent Nonwhite` = percent_nonwhite)

provider_nh_map <- map_nh %>% 
  left_join(provider_nh_summary, by = c("neighborhood" = "Neighborhood"))

ggplot(provider_nh_map) +
  geom_sf(aes(fill=`Seats per child`), color = "white") +
  scale_fill_viridis(na.value = "grey", name = "Slots per child") +
  theme_bw(base_size = 22) +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(text = element_text(family = "Montserrat"),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = "Estimated Slots per Child Ages 0 - 4",
       caption_text = "Source: Greater Louisville Project
                       Data from kynect and ACS Table B17001") +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```
  
#### Neighborhoods by Race and Licensed Slots

The neighborhoods with the highest availability of child care tend to be neighborhoods with a predominantly white population. As a result, parents of Black and Brown are more likely to have difficulty accessing child care due to where they live.

On the graph below, neighborhoods with more non-white children are located to the right, and neighborhoods with a higher prcentage of white children are to the left.
  
```{r}
avg_annotation1 <- list(
  x = 90, 
  y = mean(provider_nh_summary$`Estimated Seats`) + 150,
  xref = 'x', yref = 'y',
  text = "City Average",
  showarrow = FALSE)

avg_annotation2 <- list(
  x = 90, 
  y = sum(provider_nh_summary$`Estimated Seats`) / sum(child_pop$total) + 0.045,
  xref = 'x', yref = 'y',
  text = "City Average",
  showarrow = FALSE)

plot_ly(provider_nh_summary) %>%
  add_markers(x = ~`Percent Nonwhite`, y = ~`Estimated Seats`, 
              text = provider_nh_summary$Neighborhood,
              marker = list(color = '#d63631', size = 10),
              hoverinfo = 'text',
              visible = TRUE) %>%
  add_segments(x = 0, xend = 100, 
               y = mean(provider_nh_summary$`Estimated Seats`), 
               yend = mean(provider_nh_summary$`Estimated Seats`),
               line = list(color = '#323844', width = 1, dash = 'dash'),
               visible = TRUE) %>%
  add_markers(x = ~`Percent Nonwhite`, y = ~`Seats per child`,
              text = provider_nh_summary$Neighborhood,
              marker = list(color = '#d63631', size = 10),
              hoverinfo = 'text',
              visible = FALSE) %>%
  add_segments(x = 0, xend = 100, 
               y = sum(provider_nh_summary$`Estimated Seats`) / sum(child_pop$total), 
               yend = sum(provider_nh_summary$`Estimated Seats`) / sum(child_pop$total), 
               line = list(color = '#323844', width = 1, dash = 'dash'),
               visible = FALSE) %>%
  layout(
    font = list(family = "Montserrat"),
    
    title = "Estimated Child Care Provider Slots by Race",
    
    xaxis = list(title = "Percent of children age 0-4 who are not White"),
    yaxis = list(title = "Total Estimated Slots", rangemode = "tozero"),
    showlegend = FALSE,
    updatemenus = list(
      list(
        active = 0,
        x = 0.95,
        y = 0.85,
        buttons = list(
          list(label = "Total Estimated Slots",
               method = "update",
               args = list(list(visible = list(TRUE, TRUE, FALSE, FALSE)),
                           list(yaxis = list(title = "Total Estimated Slots", 
                                             rangemode = "tozero"),
                                annotations = list(avg_annotation1, c())))),
          list(label = "Estimated Slots per child",
               method = "update",
               args = list(list(visible = list(FALSE, FALSE, TRUE, TRUE)),
                           list(yaxis = list(title = "Estimated Slots per Child", 
                                             rangemode = "tozero"),
                                annotations = list(c(), avg_annotation2))))))))

```

### Hours

Another barrier to child care access is the hours during which providers are open. The vast majority of child care providers are open between 6am and 6pm Monday through Friday, and there is much more limited availability of child care late in the night, in the early morning, and on the weekends.

```{r time_of_day}
hours_info <- provider_hours %>%
  left_join(provider_information) %>%
  select(CLR, Capacity, Day, open_time, close_time)

all_day_seats <- hours_info %>%
  filter(abs(open_time - close_time) <= 1)

hours_info %<>%
  anti_join(all_day_seats, by = c("CLR", "Day"))

all_day_seats %<>%
  group_by(Day) %>%
  summarise(seats = sum(Capacity))

for(day in c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")) {
  for(time in seq(0, 24, by = 0.25)) {
    
    capacity <- hours_info %>%
      filter(
        Day %in% day, # Filter to day
        
        # Time is greater than opening time OR 
        #   if close time is post midnight (less than opening time), less than close time
        time >= open_time | (close_time < open_time & time <= close_time),
        
        # Time is greater than opening time OR 
        #   close time is post midnight
        time <= close_time | close_time < open_time) %>%
      summarise(seats = sum(Capacity)) %>%
      pull(seats)
    
    temp = c("Day" = day, "Time" = time, "Seats" = capacity)
    
    seat_summary <- assign_row_join(seat_summary, temp)
    
  }
}

seat_summary %<>%
  mutate(
    Time = as.numeric(Time),
    Seats = as.numeric(Seats)) %>%
  left_join(all_day_seats, by = "Day") %>%
  mutate(Seats = Seats + seats) %>%
  select(-seats) %>%
  mutate(day_category =
           case_when(Day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") ~ "Monday - Friday",
                     Day == "Saturday" ~ "Saturday",
                     Day == "Sunday" ~ "Sunday")) %>%
  group_by(Time, day_category) %>%
  summarise(Seats = round(mean(Seats), 0), .groups = "drop") %>%
  filter(Time != 0) %>%
  mutate(
    hour = trunc(Time),
    minute = str_pad((Time - hour) * 60, 2, "left", "0"),
    suffix = if_else(hour %in% 12:23, "PM", "AM"),
    hour = case_when(hour %in% c(0, 12, 24) ~ 12,
                     hour %in% 1:11 ~ hour,
                     hour %in% 13:23 ~ hour - 12),
    time = paste0(hour, ":", minute, " ", suffix),
    time_label = factor(Time, levels = Time, labels = time, ordered = TRUE))

seat_summary %<>% 
  select(
    `Day of the Week` = day_category,
    time_label,
    Seats) %>%
  pivot_wider(names_from = `Day of the Week`, values_from = Seats)

plot_ly(seat_summary,
        hoverinfo = 'text') %>%
  add_trace(x = ~time_label, y = ~`Monday - Friday`, 
            name = "Monday - Friday", type = "scatter", mode = "lines", 
            line = list(color = '#d63631', width = 4),
            hoverinfo = 'text',
            text = paste0(seat_summary$time_label,
                          "<br>Slots available: ", 
                          scales::comma(seat_summary$`Monday - Friday`, accuracy = 1),
                          "<br>Percent available: ", 
                          scales::percent(seat_summary$`Monday - Friday` / 31597, 
                                          accuracy = 0.1))) %>%
  add_trace(x = ~time_label, y = ~Saturday, name = "Saturday", type = "scatter", mode = "lines", 
            line = list(color = '#323844', width = 4),
            hoverinfo = 'text',
            text = paste0(seat_summary$time_label,
                          "<br>Slots available: ", 
                          scales::comma(seat_summary$Saturday, accuracy = 1),
                          "<br>Percent available: ", 
                          scales::percent(seat_summary$Saturday / 31597, 
                                          accuracy = 0.1))) %>%
  add_trace(x = ~time_label, y = ~Sunday, name = "Sunday", type = "scatter", mode = "lines", 
            line = list(color = '#eaab21', width = 4),
            hoverinfo = 'text',
            text = paste0(seat_summary$time_label,
                          "<br>Slots available: ", 
                          scales::comma(seat_summary$Sunday, accuracy = 1),
                          "<br>Percent available: ", 
                          scales::percent(seat_summary$Sunday / 31597, 
                                          accuracy = 0.1))) %>%
  layout(
    font = list(family = "Montserrat"),
    title = "Licensed Child Care Provider Slots by Day and Time",
    xaxis = list(title = "Time of Day"),
    yaxis = list(title = "Slots available"))

```

### Compensation of Child Care Workers

#### Ranking
A major factor restricting the expansion of child care is relatively low wages in the child care field. In 2019, the median hourly wages for Louisville child care workers was $9.78.

```{r child_care_wages_ranking}
read_and_prep <- function(file_path) {
  df <- readxl::read_excel(file_path) %>%
    janitor::clean_names() %>%
  mutate(MSA = as.numeric(area),
         h_median = as.numeric(h_median)) %>%
  filter(MSA %in% c(24340, 41180, 36420, 46140, 24860, 28940, 13820, 31140, 26900, 
                        28140, 36540, 24660, 16740, 18140, 17140, 34980, 32820) & 
           occ_title %in% c("Childcare Workers", "Child care workers")) %>%
  select(MSA, tot_emp, h_mean, a_mean, h_median, a_median) %>%
  mutate(city = case_when(
    MSA == 24340 ~ "Grand Rapids",
    MSA == 41180 ~ "St. Louis",
    MSA == 36420 ~ "Oklahoma City",
    MSA == 46140 ~ "Tulsa",
    MSA == 24860 ~ "Greenville",
    MSA == 28940 ~ "Knoxville",
    MSA == 13820 ~ "Birmingham",
    MSA == 31140 ~ "Louisville",
    MSA == 26900 ~ "Indianapolis",
    MSA == 28140 ~ "Kansas City",
    MSA == 36540 ~ "Omaha",
    MSA == 24660 ~ "Greensboro",
    MSA == 16740 ~ "Charlotte",
    MSA == 18140 ~ "Columbus",
    MSA == 17140 ~ "Cincinnati",
    MSA == 34980 ~ "Nashville",
    MSA == 32820 ~ "Memphis",
    TRUE ~ NA_character_
  ))
    
return(df)
  
}

df19 <- read_and_prep("early-childhood/bls_data/MSA_M2019_dl.xlsx") %>%
  mutate(year = 2019)

ranking(df19,
        "h_median", 
        text_size = 2, 
        plot_title = "Median Wages for Child Care Workers, 2019", 
        year = 2019,
        subtitle_text = "2019", #font didn't really work here. Could play with text size more?
        caption_text = "Source: Greater Louisville Project
                        Data from the Bureau of Labor Statistics",
        y_title = "Dollars",
        FIPS_df = FIPS_df)
```


#### Trend
The relatively low pay rate is around the 25th percentile of Louisville's peer cities. After adjusting for inflation, median wages for child care workers have fallen since 2010.

```{r child_care_wages_trend}
df18 <- read_and_prep("early-childhood/bls_data/MSA_M2018_dl.xlsx") %>%
  mutate(year = 2018)

df17 <- read_and_prep("early-childhood/bls_data/MSA_M2017_dl.xlsx") %>%
  mutate(year = 2017)

df16 <- read_and_prep("early-childhood/bls_data/MSA_M2016_dl.xlsx") %>%
  mutate(year = 2016)

df15 <- read_and_prep("early-childhood/bls_data/MSA_M2015_dl.xlsx") %>%
  mutate(year = 2015)

df14 <- read_and_prep("early-childhood/bls_data/MSA_M2014_dl.xlsx") %>%
  mutate(year = 2014)

df13 <- read_and_prep("early-childhood/bls_data/MSA_M2013_dl_1_AK_IN.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2013_dl_2_KS_NY.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2013_dl_3_OH_WY.xls")) %>%
  mutate(year = 2013)

df12 <- read_and_prep("early-childhood/bls_data/MSA_M2012_dl_1_AK_IN.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2012_dl_2_KS_NY.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2012_dl_3_OH_WY.xls")) %>%
  mutate(year = 2012)

df11 <- read_and_prep("early-childhood/bls_data/MSA_M2011_dl_1_AK_IN.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2011_dl_2_KS_NY.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2011_dl_3_OH_WY.xls")) %>%
  mutate(year = 2011)

df10 <- read_and_prep("early-childhood/bls_data/MSA_M2010_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2010_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2010_dl_3.xls")) %>%
  mutate(year = 2010)

df09 <- read_and_prep("early-childhood/bls_data/MSA_M2009_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2009_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2009_dl_3.xls")) %>%
  mutate(year = 2009)

df08 <- read_and_prep("early-childhood/bls_data/MSA_M2008_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2008_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_M2008_dl_3.xls")) %>%
  mutate(year = 2008)

df07 <- read_and_prep("early-childhood/bls_data/MSA_May2007_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_May2007_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_May2007_dl_3.xls")) %>%
  mutate(year = 2007)

df06 <- read_and_prep("early-childhood/bls_data/MSA_may2006_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_may2006_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_may2006_dl_3.xls")) %>%
  mutate(year = 2006)

df05 <- read_and_prep("early-childhood/bls_data/MSA_may2005_dl_1.xls") %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_may2005_dl_2.xls")) %>%
  bind_rows(read_and_prep("early-childhood/bls_data/MSA_may2005_dl_3.xls")) %>%
  mutate(year = 2005)

#MSA codes all change in 2004

df_t <- bind_rows(df19, df18, df17, df16, df15, df14, df13, df12, df11, df10, df09, df08, df07, df06, df05)

#inflate to 2019 dollars based on CPI
df_cpi <- tibble(
  year = 2005:2019,
  cpi_value = c(195.292, 201.592, 207.342, 215.303, 214.537, 218.056, 224.939, 229.594, 232.957,
                236.736, 237.017, 240.007, 245.120,
                251.107, 255.657)
) %>%
  mutate(multiplier = max(cpi_value)/ cpi_value) #scale to 2019 dollars

df_t <- left_join(df_t, df_cpi, by = "year")

df_t <- df_t %>%
  mutate(h_median = h_median * multiplier)

trend_cc(df_t, 
         "h_median", 
         plot_title = "Median Hourly Wages for Child Care Workers",
         y_title = "Dollars",
         caption_text = "Source: Greater Louisville Project
                         Data from the Bureau of Labor Statistics")
```

## Child Health

Child health is important for healthy child development and future success.

### Adverse Childhood Experiences

**Adverse childhood experiences are potentially traumatic events that occur in childhood. If you would prefer to skip past this section, you can do so by clicking "Child Food Security" in the sidebar.**

Adverse Childhood Experiences (ACEs) include forms of abuse, neglect, and household dysfunction. According to the CDC, "ACEs can have lasting, negative effects on health, well-being, and opportunity." In 2018, 71% of Louisville adults reported experiencing one or more ACEs during their childhood.

To understand the questionnaire and find your ACE score, you can [click here.](https://www.npr.org/sections/health-shots/2015/03/02/387007941/take-the-ace-quiz-and-learn-what-it-does-and-doesnt-mean)

ACEs data was collected by the Kentucky BRFSS survey using phone interviews throughout 2018.
Kentucky Department for Public Health (KDPH) and the Centers for Disease Control and Prevention (CDC). *Kentucky Behavioral Risk Factor Survey Data - Adverse Childhood Experiences 2015&2018.* Frankfort, Kentucky: Cabinet for Health and Family Services, Kentucky Department for Public Health, **[2018]**.

#### Impact of ACEs

Louisville adults who have experienced a high number of ACEs report much higher numbers of chronic disease than those who experienced no ACEs. The chart below compares the prevalence of several healh conditions among the two groups. The data is based on the health status of current adults based on the number of ACEs they report having experienced as a child.

Compared to adults who experienced no ACEs, adults who experienced a high number of ACEs are 6.5 times as likely to be a current smoker, 2.2 times as likely to report poor health status, 6.3 times as likely to have had a heart attack, and 3.9 times as likely to have depression.

![ACE risk factors](images/ACEs risk factors.png)

#### Prevelance of ACEs

#### ACE scores

In 2018, 71% of adults in Louisville reported experiencing at least one ACE when they were a child. Higher numbers of ACEs are associated with greater prevalence of risk factors and chronic disease.

```{r}
ace_prevelance <- tibble(
  number = c(0:4, "5+"),
  percent = c(29, 20.8, 17.8, 10, 10, 12.4)) %>%
  mutate(
    number = factor(number, levels = rev(c(0:4, "5+")), ordered = T),
    label_text = scales::percent(percent, scale = 1),
    ypos = cumsum(percent) - 0.5 * percent)

text_size = 2

p <- ggplot(ace_prevelance, aes(x=factor(1), y=percent))

p = p + guides(fill = FALSE, color = FALSE)

p <- p +
  geom_bar(aes(alpha = number),
           stat = "identity",
           width = 1,
           size = text_size,
           fill = "#d63631") +
  scale_alpha_manual(
    name = "Number of ACEs",
    breaks = c(0:4, "5+"), values = seq(0.2, 1, length.out = 6)) +
  coord_polar("y") +
  theme_void() +
  geom_text(aes(label = label_text, family = "Montserrat"), 
            color = "black", size = 12, position = position_stack(vjust = 0.5))

p <- p + theme(text = element_text(family = "Montserrat"),
               plot.title = element_text(size = 14 * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
               plot.caption = element_text(size = 10 * text_size, lineheight = 0.5),
               legend.text = element_text(size = 12 * text_size, lineheight = 0.5),
               legend.title = element_text(size = 12 * text_size))

p <- p + labs(title = "Percentage of Louisville adults by ACE score, 2018",
              caption = "Source: Greater Louisville Project
                         Data from the Kentucky Behavioral Risk Factor Survey")

p <- p +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

p

```

#### Type of ACEs

The most common ACE Louisville adults report experiencing as a child is divorce among their parents, followed by a drinking problem in the household. Over one quarter of adults reported experiencing verbal abuse as a child.

```{r}
ace_types <- tibble(
  category = c(rep("abuse", 3), rep("dysfunction", 6)),
  type = c("physical_abuse", "sexual_abuse", "verbal_abuse",
           "incarcerated_hh_member", "drug_problem", "drinking_problem",
           "witness_domestic_violence", "mentally_ill_hh_member", "divorced_parents"),
  percent = c(12.5, 15.4, 28.2, 9.7, 16.9, 31.6, 20.5, 26.1, 41.8))

ace_types %<>%
  mutate(type = factor(type, 
                       levels = c("verbal_abuse",
                                  "sexual_abuse", 
                                  "physical_abuse",
                                  "divorced_parents",
                                  "drinking_problem",
                                  "mentally_ill_hh_member", 
                                  "witness_domestic_violence", 
                                  "drug_problem",
                                  "incarcerated_hh_member"),
                       labels = c("Verbal abuse",
                                  "Sexual abuse", 
                                  "Physical abuse", 
                                  "Divorced Parents",
                                  "Drinking problem in household",
                                  "Mentally ill household member", 
                                  "Witnessed domestic violence", 
                                  "Drug problem in household",
                                  "Incarcerated household member"),
                       ordered = TRUE))

ace_types %<>%
  mutate(label_text = scales::percent(percent, scale=1, accuracy = 1))

text_size = 2

p <- ggplot(ace_types, aes(type, percent))

p = p + guides(fill = FALSE, color = FALSE)

p <- p +
  geom_bar(stat = "identity",
           size = text_size,
           fill = "#d63631") +
  coord_flip(clip="off") +
  ggthemes::theme_tufte()

p <- p + theme(text = element_text(family = "Montserrat"),
               plot.title = element_text(size = 13.5 * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
               axis.text.y = element_text(hjust = 0,
                                          size = 10 * text_size),
               axis.title.x = element_text(size = 10 * text_size),
               axis.title.y = element_text(size = 10 * text_size),
               axis.ticks = element_blank(),
               axis.text.x = element_blank(),
               plot.caption = element_text(size = 10 * text_size, lineheight = 0.5))

# p <- p +
#   labs(subtitle = subtitle_text) +
#   theme(plot.subtitle = element_text(hjust = 0.5, size = 10 * text_size))

# Add remaining text
p <- p + labs(title = "Prevelance of ACEs among Louisville adults, 2018",
              y = "Percent",
              x = "",
              caption = "Souce: Greater Louisville Project
                         Data from the Kentucky Behavioral Risk Factor Survey")

p <- p +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

p <- p + geom_text(aes(label = label_text,
                       family = "Montserrat Bold"),
                   size = 4.5 * text_size,
                   color = "black",
                   hjust = 1.1)

p


```

#### ACEs by race

The most recent national data from the National Survey of Children’s Health shows that [children who are Hispanic or Black are more likely to have experienced one or more ACEs than other children.](https://www.cahmi.org/wp-content/uploads/2018/05/aces_fact_sheet.pdf). While we have some local data for children of different races, it is limited and highly variable from year to year. The original ACEs questionnaire mostly measures trauma that occurs in the home, and it excludes many kinds of trauma that are most likely to affect Black and Brown children, such as racial discrimination from peers, experiences with community violence, and family separation.

There are various proposals to create a more comprehensive Expanded or Culturally-Informed ACEs measure. Some suggestions include adding questions about community experiences, such as witnessing violence or living in unsafe neighborhoods. Proposals also include collecting more data on experiences with racism, including discrimination, stigma, and historical trauma. Racism is both a source of trauma and an amplifier of other kinds of trauma.

### Child Food Security

Child food security data comes from the Feeding America's Mind the Meal Gap program. According to Feeding America, "research shows an association between food insecurity and delayed development in young children; risk of chronic illnesses like asthma and anemia; and behavioral problems like hyperactivity, anxiety and aggression in school-age children."

#### Trend

From 2014 to 2018, Louisville saw a slight decline in child food insecurity. However, child food insecurity increased by 40% in Louisville from 2018 to October of 2020.

```{r}
# Read in food insecurity data from Mind the Meal Gap
dinner_time <- function(folder, starting_year){
  
  wd <- getwd()
  directory <- paste0(wd, "/", folder)
  file_names <- list.files(directory)
  
  # Read file for each year
  for (y in starting_year:2018){
    
    # Create parameters to read in sheet based on the year
    file_path <- paste0(wd, "/", folder, "/", file_names[y-2008])
    
    sheet_name <- case_when(
      y %in% 2009:2010 ~ "County",
      y %in% 2011:2018 ~ paste0(y, " County"))
    
    skip_num <- case_when(
      y %in% 2009:2017 ~ 0,
      y %in% 2018 ~ 1)
    
    df <- readxl::read_xlsx(file_path, sheet = sheet_name, skip = skip_num)

    # Create variables names based on the year
    food_insecure_var <- paste0(y, " Food Insecurity Rate")
    food_insecure_num_var <- paste0("# of Food Insecure Persons in ", y)
    child_food_insecure_var <- paste0(y, " Child food insecurity rate")
    child_food_insecure_num_var <- paste0("# of Food Insecure Children in ", y)
    insecure_FRL <- paste0("% food insecure children in HH w/ HH incomes below 185 FPL in ", y)
    insecure_non_FRL <- paste0("% food insecure children in HH w/ HH incomes above 185 FPL in ", y)

    # Tidy data frame
    df %<>%
      transmute(
        FIPS = str_pad(FIPS, 5, "left", "0"),
        year = y,
        food_insecurity = .data[[food_insecure_var]],
        food_insecurity_num = .data[[food_insecure_num_var]],
        child_food_insecurity = .data[[child_food_insecure_var]],
        child_food_insecurity_num = .data[[child_food_insecure_num_var]],
        
        low_threshold = `Low Threshold in state`,
        low_threshold_type = `Low Threshold Type`,
        high_threshold = `High Threshold in state`,
        high_threshold_type = `High Threshold Type`,
        under_low = `% FI ≤ Low Threshold`,
        between = `% FI Btwn Thresholds`,
        above = `% FI > High Threshold`,
        child_below_FRL = .data[[insecure_FRL]],
        child_above_FRL = .data[[insecure_non_FRL]])

    output <- assign_row_join(output, df)
  }
  output
}

feeding_america <- dinner_time("early-childhood/raw_data/Map the Meal Gap data", starting_year = 2012)
feeding_america_covid <- readxl::read_xlsx("early-childhood/raw_data/Projections data (revised Oct. 2020)/The Impact of Coronavirus on Food Insecurity Update 10.2020.xlsx", sheet = "County")

feeding_america_covid %<>%
  transmute(
    FIPS = str_pad(FIPS, 5, "left", "0"),
    year = 2020,
    food_insecurity = `[Revised Projections – Oct 2020] \r\n2020 Food Insecurity  %`,
    food_insecurity_num = `[Revised Projections – Oct 2020] \r\n2020 Food Insecurity #`,
    child_food_insecurity = `[Revised Projections – Oct 2020] \r\n2020 Child Food Insecurity  %`,
    child_food_insecurity_num = `[Revised Projections – Oct 2020] \r\n2020 Child Food Insecurity #`)

feeding_america %<>%
  bind_rows(feeding_america_covid)

feeding_america %<>% 
  pull_peers(FIPS_df = FIPS_df) %>%
  mutate(across(
    c(food_insecurity, child_food_insecurity, under_low, between, above, child_below_FRL, child_above_FRL), 
    ~ . * 100))

feeding_america_1 <- feeding_america %>%
  stl_merge(food_insecurity_num, child_food_insecurity_num, method = "sum")

feeding_america_2 <- feeding_america %>%
  stl_merge(food_insecurity, under_low, between, above, method = "mean", weight_var = "food_insecurity_num")

feeding_america_3 <- feeding_america %>%
  stl_merge(child_food_insecurity, child_below_FRL, child_above_FRL, method = "mean", weight_var = "child_food_insecurity_num")

feeding_america_t = left_join(feeding_america_1, feeding_america_2) %>%
  left_join(feeding_america_3)

feeding_america_t %<>%
  mutate(pct_above_frl = child_above_FRL * child_food_insecurity / 100,
         pct_below_frl = (100 - child_above_FRL) * child_food_insecurity / 100)

trend_cc(feeding_america_t,
         "child_food_insecurity", 
         plot_title = "Child Food Insecurity",
         caption_text = "Source: Greater Louisville Project
                         Data from Feeding America",
         y_title = "Percent",
         xmin = 2014, xmax = 2020)
```

#### Ranking

While Louisville is toward the middle of its peer cities in child food Insecurity, more than 1 in 5 children are food insecure.
```{r}
ranking(feeding_america_t, 
        "child_food_insecurity",
        plot_title = "Child Food Insecurity, October 2020",
        caption_text = "Source: Greater Louisville Project
                        Data from Feeding America",
        year = 2020,
        order = "Ascending",
        text_size = 2,
        FIPS_df = FIPS_df)
```

#### Breakdown by Program Eligibility

As of 2018, Feeding America estimated that most food-insecure children lived in families under 185% of the poverty line, meaning that they were generally eligible for programs like SNAP, WIC, and Free or Reduced School lunch.

Compared to cities with similar rates of overall child food insecurity, Louisville has a relatively low number of food insecure children who are eligible for food benefit programs and a relatively high number of food insecure children above this cutoff. This shows that food insecurity is prevalent in families with a wide range of incomes.

```{r}
feeding_america_stack <- feeding_america_t %>%
  filter(year == 2018) %>%
  pull_peers(add_info = T, FIPS_df = FIPS_df) %>%
  filter(current == 1) %>%
  arrange(child_food_insecurity) %>%
  mutate(
    rank = row_number(),
    names = paste0(rank, ". ", city))

feeding_america_stack %<>%
  select(names, rank, city, pct_below_frl, pct_above_frl) %>%
  pivot_longer(pct_below_frl:pct_above_frl) %>%
  arrange(desc(name)) %>%
  group_by(city) %>%
  mutate(label_ypos = if_else(name == "pct_below_frl", 
                              value[name == "pct_below_frl"], 
                              sum(value)))

color_values <- c("#323844", "#d63631")
color_names <- c("Above 185% of poverty", "Below 185% of poverty")

feeding_america_stack$color <- "Below 185% of poverty"
feeding_america_stack$color[feeding_america_stack$name == "pct_above_frl"] <- "Above 185% of poverty"

feeding_america_stack$alpha = 0.9
feeding_america_stack$alpha[feeding_america_stack$city == "Louisville"] <- 1

# Create numeric labels
label_text <- feeding_america_stack$value %>%
  scales::percent(accuracy = 0.1, scale = 1, suffix = "%")


# Set text format, highlight and italicise Louisville text, highlight Louisville bar
feeding_america_stack$textcolor <- "#000000"
feeding_america_stack$textcolor[feeding_america_stack$name == "pct_above_frl"] <- "#000000"

feeding_america_stack$textfont <- "Montserrat"
feeding_america_stack$textfont[feeding_america_stack$city == "Louisville"] <- "Montserrat Bold"

label_color_names <- c("white", "black")
label_color_values <- c("#000000", "#ffffff")

feeding_america_stack$label_color <- "white"
feeding_america_stack$label_color[feeding_america_stack$name == "pct_above_frl"] <- "black"
#df$linecolor <- "#ffffff"
#df$linecolor[df$city == "Louisville"] <- "#00a9b7"
feeding_america_stack$lou <- if_else(feeding_america_stack$city == "Louisville", 1, 0)
feeding_america_stack$text_alignment <- 1.1
feeding_america_stack$text_alignment[feeding_america_stack$city %in% "Grand Rapids" &
                                     feeding_america_stack$name == "pct_above_frl"] <- 1.02
### PLOT GRAPH

text_size = 2

# Initial plot
p <- ggplot(data = feeding_america_stack,
            aes(x = factor(names, levels = unique(rev(names))),
                y = value,
                alpha = alpha))
p <- p + guides(color = FALSE, alpha = FALSE)
# Add bars
p <- p +
  geom_bar(aes(fill = factor(color, levels = color_names, ordered = TRUE)),
           stat = "identity",
           size = text_size) +
  coord_flip() +
  ggthemes::theme_tufte()

p <- p + scale_fill_manual(values = color_values, guide = guide_legend(reverse = TRUE)) + 
  scale_alpha(range = c(0.8, 1))

text_scale <- 2

#p <- p + scale_color_manual(values = c("#ffffff", "#00a9b7"))
# Add features
title_scale <- min(1, 48 / nchar("Child Food Security"))

p <- p + theme(text = element_text(family = "Montserrat"),
               plot.title = element_text(size = 14 * title_scale * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
               legend.text = element_text(size = 10 * text_scale,
                                margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),
               axis.text.y = element_text(hjust = 0,
                                          size = 10 * text_size,
                                          color = rev(feeding_america_stack$textcolor),
                                          family = rev(feeding_america_stack$textfont)),
               axis.title.y = element_blank(),
               axis.title.x = element_text(size = 10 * text_size),
               axis.ticks = element_blank(),
               axis.text.x = element_blank(),
               plot.caption = element_text(size = 10 * text_size, lineheight = 0.5),
               legend.title = element_blank())

p <- p +
  labs(caption = "Source: Greater Louisville Project
                  Data from Feeding America")


# Add numeric labels to bars based on bar_label parameter
p <- p + geom_text(aes(label = label_text,
                       hjust = text_alignment,
                       color = factor(label_color),
                       family = textfont,
                       group = name,
                       y = label_ypos),
                   position = "identity",
                   size = 4.5 * text_size) +
  scale_colour_manual(values=c("#ffffff", "#000000"))

# Add vertical line to the left side of the bars based on the h_line parameter

# Add remaining text
p <- p + labs(title = "Child Food Security",
              y = "Percent") +
  theme(legend.position = "bottom")

p <- p +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

p
```


<!--chapter:end:early_childhood.Rmd-->

---
title: "Internet Access in Louisville"
author: "Nate Kratzer"
date: '2020-09-09'
output:
  html_document:
    self_contained: no
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

# Digital Divide 

```{r setup1, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      dev = "png", dev.args = list(type = "cairo-png"))

#knitr::opts_chunk$set(dev.args=list(bg="transparent"))
```

```{r xaringan-panelset1, echo=FALSE}
xaringanExtra::use_panelset()
```


```{r, eval = FALSE}
#Filtering to just GLP peer MSAs
library(tidyverse)

df <- read_csv(
  "ipums_internet_access/glp_int.csv",
  col_types = cols(
    YEAR = col_double(),
    SAMPLE = col_double(),
    SERIAL = col_double(),
    CBSERIAL = col_double(),
    HHWT = col_double(),
    CLUSTER = col_double(),
    STATEFIP = col_double(),
    METRO = col_double(),
    MET2013 = col_double(),
    PUMA = col_double(),
    STRATA = col_double(),
    GQ = col_double(),
    CINETHH = col_double(),
    CILAPTOP = col_double(),
    CISMRTPHN = col_double(),
    CITABLET = col_double(),
    CIHISPEED = col_double(),
    CIDIAL = col_double(),
    PERNUM = col_double(),
    PERWT = col_double(),
    SEX = col_double(),
    AGE = col_double(),
    RACE = col_double(),
    RACED = col_double(),
    HISPAN = col_double(),
    HISPAND = col_double(),
    EDUC = col_double(),
    EDUCD = col_double(),
    POVERTY = col_double(),
    city = col_character()
  )
)

df_city <- df %>%
  filter(MET2013 %in% c(24340, 41180, 36420, 46140, 24860, 28940, 13820, 31140, 26900, 
                        28140, 36540, 24660, 16740, 18140, 17140, 34980, 32820)) %>%
  mutate(city = case_when(
    MET2013 == 24340 ~ "Grand Rapids",
    MET2013 == 41180 ~ "St. Louis",
    MET2013 == 36420 ~ "Oklahoma City",
    MET2013 == 46140 ~ "Tulsa",
    MET2013 == 24860 ~ "Greenville",
    MET2013 == 28940 ~ "Knoxville",
    MET2013 == 13820 ~ "Birmingham",
    MET2013 == 31140 ~ "Louisville",
    MET2013 == 26900 ~ "Indianapolis",
    MET2013 == 28140 ~ "Kansas City",
    MET2013 == 36540 ~ "Omaha",
    MET2013 == 24660 ~ "Greensboro",
    MET2013 == 16740 ~ "Charlotte",
    MET2013 == 18140 ~ "Columbus",
    MET2013 == 17140 ~ "Cincinnati",
    MET2013 == 34980 ~ "Nashville",
    MET2013 == 32820 ~ "Memphis",
    TRUE ~ NA_character_
  )) %>%
  write_csv("ipums_internet_access/glp_int_MSAs.csv")
```


## Overall Access

This report uses census Microdata from IPUMS to look at internet access in the Louisville MSA. Data is available from 2013 to 2018. About 1 in 10 households in Louisville have no internet access, and 3 in 10 do not have the high speed access necessary for working and learning at home. Access to high speed internet access has not improved in the past 6 years. Households also lack access to devices, with 15% of houses not having a computer or a tablet. Houses that do have computers or tablets are also unlikely to have enough devices for multiple people working from home (unfortunately the Census data only asks about having 1 or more device). 

```{r}
# Libraries
library(tidyverse)
library(survey)
library(glptools)
library(classInt)
library(ggthemes)
library(ggplot2)
library(rgdal)
library(sf)
library(magrittr)

library(showtext)
library(kableExtra)

showtext_auto()
font_add("Montserrat", "Black_wealth/Montserrat/Montserrat-Regular.ttf")
font_add("Montserrat Bold", "Black_wealth/Montserrat/Montserrat-SemiBold.ttf")

df <- read_csv(
  "ipums_internet_access/glp_int_MSAs.csv",
  col_types = cols(
    YEAR = col_double(),
    SAMPLE = col_double(),
    SERIAL = col_double(),
    CBSERIAL = col_double(),
    HHWT = col_double(),
    CLUSTER = col_double(),
    STATEFIP = col_double(),
    METRO = col_double(),
    MET2013 = col_double(),
    PUMA = col_double(),
    STRATA = col_double(),
    GQ = col_double(),
    CINETHH = col_double(),
    CILAPTOP = col_double(),
    CISMRTPHN = col_double(),
    CITABLET = col_double(),
    CIHISPEED = col_double(),
    CIDIAL = col_double(),
    PERNUM = col_double(),
    PERWT = col_double(),
    SEX = col_double(),
    AGE = col_double(),
    RACE = col_double(),
    RACED = col_double(),
    HISPAN = col_double(),
    HISPAND = col_double(),
    EDUC = col_double(),
    EDUCD = col_double(),
    POVERTY = col_double(),
    city = col_character()
  )
)

df <- df %>%
  mutate(
    int_acc = case_when(
      CINETHH == 0 ~ NA_real_,
      CINETHH == 1 ~ 1,
      CINETHH == 2 ~ 1,
      CINETHH == 3 ~ 0),
    hspd_int = case_when(
      CINETHH == 0 ~ NA_real_,
      CINETHH == 3 & CIHISPEED == 0 ~ 0, #seems like it's marked NA if the household doesn't have internet access. We want it to be no High Speed access
      CIHISPEED > 9 & CIHISPEED < 20 ~ 1,
      CIHISPEED == 20 ~ 0
    ),
    computer = case_when(
      CILAPTOP == 0 ~ NA_real_,
      CILAPTOP == 1 ~ 1,
      CILAPTOP == 2 ~ 0
    ),
    tablet = case_when(
      CITABLET == 0 ~ NA_real_,
      CITABLET == 1 ~ 1,
      CITABLET == 2 ~ 0
    ),
    comp_tab = case_when(
      computer == 1 | tablet == 1 ~ 1,
      computer == 0 & tablet == 0 ~ 0,
      TRUE ~ NA_real_
    ),
    hspd_dev = case_when(
      comp_tab == 1 & hspd_int == 1 ~ 1,
      comp_tab == 0 | hspd_int == 0 ~ 0,
      TRUE ~ NA_real_
    )
  )


# These questions are usually only NA for group quarters
# All the NA rows are the same for all categories in the Louisville sample
df_na <- df %>%
  filter(!is.na(int_acc))

svy_df <- svydesign(ids = ~ 1, weights = ~PERWT, data = df_na)

int_tbl <- svyby(~int_acc, ~YEAR+city, design = svy_df, svymean)

#Even accounting for not asking people without internet if they had hi speed internet 
df_na <- df %>%
  filter(!is.na(hspd_int))

svy_df <- svydesign(ids = ~ 1, weights = ~PERWT, data = df_na)

hspd_tbl <- svyby(~hspd_int, ~YEAR+city, design = svy_df, svymean)

df_na <- df %>%
  filter(!is.na(comp_tab) & !is.na(hspd_dev))

svy_df <- svydesign(ids = ~ 1, weights = ~PERWT, data = df_na)

hspd_dev_tbl <- svyby(~hspd_dev, ~YEAR+city, design = svy_df, svymean)
comp_tab_tbl <- svyby(~comp_tab, ~YEAR+city, design = svy_df, svymean)

ranking <- function(df, var, plot_title = "",
                    year = NULL, sex = "total", race = "total", peers = "Current",
                    order = "Descending",
                    y_title = "Percent", caption_text = "", subtitle_text = "",
                    bar_label = TRUE, sigfig = 3, accuracy = 0.1,
                    label_function, alternate_text = NULL,
                    ranking_colors = TRUE, text_size){

  # Copy variable var to a new column for use with the '$' operator
  var <- dplyr:::tbl_at_vars(df, vars(!!enquo(var)))
  df$var <- df[[var]]

  # Filter to sex, race, and year
  if ("sex" %in% names(df)) df <- df[df$sex == sex,]
  if ("race" %in% names(df)) df <- df[df$race == race,]
  if("year" %in% names(df)) {
    if (is.null(year)) year <- max(years_in_df(df, var))
    df <- df[df$year %in% year,]

    if (length(year) > 1) {
      df %<>%
        group_by_at(df %cols_in% c("MSA", "FIPS")) %>%
        summarise(var = mean(var, na.rm = TRUE)) %>%
        ungroup()
    }
  }

  # Add peer data if not already present
  if ("current" %not_in% names(df)) df %<>% pull_peers(add_info = T)

  # Filter to peer parameter
  if (peers %in% c("current", "Current"))   df %<>% filter(current == 1)
  if (peers %in% c("baseline", "Baseline")) df %<>% filter(baseline == 1)

  # Sort according to order parameter
  if (order %in% c("descending", "Descending")) df %<>% arrange(desc(var))
  if (order %in% c("ascending", "Ascending"))   df %<>% arrange(var)

  df %<>% filter(!is.na(var))

  # Create numbered city labels for left side of graph
  df %<>%
    mutate(
      rank = row_number(),
      names = paste0(rank, ". ", city))

  # Set bar colors
  if (ranking_colors) {

    # color_values <- c("#96ca4f", "#ffd600", "#db2834")
    # color_names <- c("green", "yellow", "red")
    # if (order %in% c("descending", "Descending")) {color_names  = rev(color_names)}
    # 
    # breaks <- classInt::classIntervals(na.omit(df$var), 3, style = "jenks")
    # df$color <- NA
    # df$color[df$var <= breaks$brks[2]] <- color_names[1]
    # df$color[df$var > breaks$brks[2] & df$var <= breaks$brks[3]] <- color_names[2]
    # df$color[df$var > breaks$brks[3]] <- color_names[3]
    
    color_values <- c("#d63631", "#323844")
    color_names <- c("gray", "red")
    
    df$color <- "gray"
    df$color[df$city == "Louisville"] <- "red"

  } else {
    df$color <- "blue"
    color_values <- "#f58021"
    color_names <- "blue"
  }

  if (order %in% c("descending", "Descending")) color_values = rev(color_values)

  # Create numeric labels
  if (!missing(label_function)) {
    label_text <- df$var %>% signif(sigfig) %>% label_function()
  } else if (y_title == "Dollars") {
    if (mean(df$var, na.rm = TRUE) > 10000) {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = accuracy, scale = .001, suffix = "k")
    } else if (mean(df$var, na.rm = TRUE) > 100){
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = 1)
    } else {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = .01)
    }
  } else if (stringr::str_detect(y_title, "Percent")) {
    label_text <- df$var %>% signif(sigfig) %>% scales::percent(accuracy = accuracy, scale = 1, suffix = "%")
  } else {
    label_text <- df$var %>% signif(sigfig) %>% scales::comma(accuracy = accuracy)
  }

  # Set text format, highlight and italicise Louisville text, highlight Louisville bar
  df$textcolor <- "#000000"
  df$textcolor[df$city == "Louisville"] <- "#000000"
  
  df$textfont <- "Montserrat"
  df$textfont[df$city == "Louisville"] <- "Montserrat Bold"
  
  label_color_names <- c("white", "black")
  label_color_values <- c("#000000", "#ffffff")
  
  df$label_color <- "white"
  df$label_color[df$city == "Louisville"] <- "black"

  #df$linecolor <- "#ffffff"
  #df$linecolor[df$city == "Louisville"] <- "#00a9b7"

  df$lou <- if_else(df$city == "Louisville", 1, 0)

  df$text_alignment <- 1.1
  if (!is.null(alternate_text)) df$text_alignment[df$rank %in% alternate_text] <- -0.1

  ### PLOT GRAPH
  
  # Initial plot
  p <- ggplot(data = df,
              aes(x = factor(names, levels = rev(names)),
                  y = var,
                  fill  = factor(color, levels = color_names, ordered = TRUE)))

  p <- p + guides(fill = FALSE, color = FALSE)

  # Add bars
  p <- p +
    geom_bar(stat = "identity",
             size = text_size) +
    coord_flip() +
    ggthemes::theme_tufte()

  p <- p + scale_fill_manual(values = color_values)
  #p <- p + scale_color_manual(values = c("#ffffff", "#00a9b7"))

  # Add features
  title_scale <- min(1, 48 / nchar(plot_title))

  p <- p + theme(text = element_text(family = "Montserrat"),
                 plot.title = element_text(size = 74 * title_scale * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
                 axis.text.y = element_text(hjust = 0,
                                            size = 40 * text_size, 
                                            color = rev(df$textcolor),
                                            family = rev(df$textfont)),
                 axis.title.x = element_text(size = 60 * text_size),
                 axis.ticks = element_blank(),
                 axis.text.x = element_blank(),
                 plot.caption = element_text(size = 36 * text_size, lineheight = 0.5))

  if(subtitle_text != ""){
    p <- p + theme(plot.subtitle = element_text(hjust = 0.5, size = 60 * text_size)) +
      labs(subtitle = subtitle_text)
  }

  # Add numeric labels to bars based on bar_label parameter
  if (y_title != "" & bar_label) {
    p <- p + geom_text(aes(label = label_text, 
                           hjust = text_alignment, 
                           color = factor(label_color),
                           family = textfont),
                       size = 14 * text_size) +
       scale_colour_manual(values=c("#000000", "#ffffff"))
    }

  # Add vertical line to the left side of the bars based on the h_line parameter
  if (min(df$var, na.rm = TRUE) < 0) p <- p + geom_hline(yintercept = 0, linetype = "longdash", size = 2)

  # Add remaining text
  p <- p + labs(title = plot_title, y = y_title,
                x = "", caption = caption_text)
  
  p
}

int_2018 <- int_tbl %>%
  filter(YEAR == 2018) %>%
  mutate(current = 1,
         int_acc = int_acc * 100)

hspd_2018 <- hspd_tbl %>%
  filter(YEAR == 2018) %>%
  mutate(current = 1,
         hspd_int = hspd_int * 100)

comp_tab_2018 <- comp_tab_tbl %>%
  filter(YEAR == 2018) %>%
  mutate(current = 1,
         comp_tab = comp_tab * 100)

hspd_dev_2018 <- hspd_dev_tbl %>%
  filter(YEAR == 2018) %>%
  mutate(current = 1,
         hspd_dev = hspd_dev * 100)
  

plt1 <- ranking(int_2018, int_acc,
                plot_title = "Internet Access",
                subtitle_text = "2018", text_size = .60) 

plt2 <- ranking(hspd_2018, hspd_int,
                plot_title = "High Speed Internet Access",
                subtitle_text = "2018", text_size = .60)

plt3 <- ranking(comp_tab_2018, comp_tab,
                plot_title = "Computer or Tablet in Household",
                subtitle_text = "2018", text_size = .60)

plt4 <- ranking(hspd_dev_2018, hspd_dev,
                plot_title = "High Speed Internet and Device",
                subtitle_text = "2018", text_size = .60)
```

### High Speed Internet

Our focus on internet access is a focus on high speed access. While internet access over a smartphone or other non high speed source can be useful for staying connected, in the COVID era of working and learning from home high speed internet is a necessary utility that over a quarter of our households do not have. While 91% of houses have some form of internet access, only 73% have high speed internet access. 

```{r}
plt2
```

### Digital Devices

A full 15% of our households do not have either a computer or tablet at home, and this understates the extent of the internet device shortage, as a single device is insufficient for a household with multiple people working and learning. 

```{r}
plt3
```

### Internet and Devices

Finally, we can also look at the overlap of having both high speed internet and a device to work on. At 71% this is fairly similar to the numbers with high speed internet, suggesting that most people with high speed internet do have at least one device capable of accessing it. 

```{r}
plt4
```

## The Digital Divide in Jefferson County

We can also take a deeper look into internet access within Louisville. We'll focus on high speed internet. While devices are also important, the data doesn't let us know how many devices are in each household, so it's guidance on the magnitude of the device shortage is quite limited. 

### Internet Speed

While our focus is on high speed access, we do show the history of both all internet access and high speed access in the graph below. Although overall internet access has increased a little since 2013, high speed internet access remains flat or possibly slightly below 2013 levels. 
In 2016, the Census Bureau began asking about smart phones for the first time. Although the internet access question was not changed, the addition of the question about smartphones may still explain the jump in consumers reporting that they had internet acess at home. There is no similar uptick in high speed access.  
```{r jeff co}
#Cut the data down to just Jefferson County
# df_msa <- df %>%
#   filter(MET2013 == 31140)
# 
# df_jeff <- df_msa %>%
#   filter(PUMA %in% c("1701", "1702", "1703", "1704", "1705", "1706")) %>%
#   write_csv("jeff_co_int.csv")


df <- read_csv("ipums_internet_access/jeff_co_int.csv")


# See if there's data on high speed internet access at the tract level 

df <- df %>%
  mutate(poverty = if_else(POVERTY < 100 & POVERTY != 000, 1, 0),
         under65 = if_else(AGE < 65, 1, 0))

df_na <- df %>%
  filter(!is.na(hspd_int))

svy_df <- svydesign(ids = ~ 1, weights = ~PERWT, data = df_na)

hint_tbl <- svyby(~hspd_int, ~YEAR, design = svy_df, svymean)
hint_tbl_count <- svyby(~hspd_int, ~YEAR, design = svy_df, svytotal)
int_tbl <- svyby(~int_acc, ~YEAR, design = svy_df, svymean)
int_pov_tbl <- svyby(~hspd_int, ~YEAR+poverty, design = svy_df, svymean)
int_age_tbl <-svyby(~hspd_int, ~YEAR+under65, design = svy_df, svymean)
int_race_tbl <- svyby(~hspd_int, ~YEAR+RACE, design = svy_df, svymean)


hint_tbl <- hint_tbl %>%
  mutate(int = hspd_int * 100,
         se100 = se * 100,
         `High Speed` = "High Speed")

int_tbl <- int_tbl %>%
  mutate(int = int_acc * 100,
         se100 = se * 100,
         `High Speed` = "All Internet") %>%
  bind_rows(hint_tbl)

plt_by <- function(df, group_var, title_text = "Internet Access") {
  group_var <- enquo(group_var)

  text_scale <- 1
  
  plt <- ggplot(data = df, aes(x = YEAR, y = int, group = !!group_var, colour = !!group_var)) +
    geom_errorbar(aes(ymin = int - (1.96 * se100), ymax = int + 1.96 * se100), width = .1) +
    geom_point(size = 2) +
    geom_line(size = .65) +
    theme_bw() +
    labs(title = title_text, x = "Year", y = "Percent") +
    theme(legend.position = "bottom")
  
  plt <- plt  + 
    scale_colour_manual(values = c("#323844", "#d63631")) +
    theme(text = element_text(family = "Montserrat"),
          
          legend.title     = element_text(size = 30 * text_scale),
          legend.text      = element_text(size = 24 * text_scale,
                                          margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),

          axis.text    = element_text(size = 24 * text_scale),
          axis.title   = element_text(size = 30 * text_scale),
          axis.title.x = element_text(margin = margin(t = 0.3 * text_scale, unit = "cm")),
          axis.title.y = element_text(margin = margin(r = 0.3 * text_scale, unit = "cm")),
      
          plot.title = element_text(size = 42 * text_scale,
                                    hjust = .5,
                                    margin = margin(b = 0.4 * text_scale, unit = "cm")))

  plt <- plt +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA)
  )
  
  plt
}

plt_int <- plt_by(int_tbl, `High Speed`)

plt_int


# plt_int <- ggplot(int_tbl, aes(x = YEAR, y = int)) +
#   geom_errorbar(aes(ymin = int - (1.96 * se100), ymax = int + 1.96 * se100), width = .1) +
#   geom_line() +
#   geom_point() +
#   theme_bw() +
#   labs(title = "Household Internet Access", x = "Year", y = "Percent") +
#   theme(legend.position = "bottom")
# 
# plt_int
```

### Poverty

HIgh speed internet access for households in poverty has been _decreasing_ since 2013. 

```{r poverty_int}
int_pov_tbl <- int_pov_tbl %>%
  mutate(Poverty = if_else(poverty == 0, "Above Poverty Line", "Below Poverty Line"),
         int = hspd_int * 100,
         se100 = se * 100)

plt_pov <- plt_by(int_pov_tbl, Poverty)

plt_pov
```

### Race

High speed internet access has either remained steady or slightly declined for Black households in Louisville. 

```{r race}
int_race_tbl <- int_race_tbl %>%
  filter(RACE < 3) %>% #Louisville's racial groups other than White and Black have small populations leading to low sample sizes
  mutate(Race = if_else(RACE == 1, "White", "Black"),
         int = hspd_int * 100,
         se100 = se * 100)

plt_race <- plt_by(int_race_tbl, Race, title_text = "High Speed Internet Access")

plt_race
```

### Age

Households with adults age 65 and older is one of the only household groupings where high speed internet access has actually increased over time

```{r}
int_age_tbl <- int_age_tbl %>%
  mutate(int = hspd_int * 100,
         se100 = se * 100,
         Age = if_else(under65 == 1, "Under 65", "65 and Older"))

plt_age <- plt_by(int_age_tbl, Age, title_text = "High Speed Internet Access")

plt_age
```

## Child Internet Access


### School Age

In this section, we limit the scope of our analysis to look at children ages 5-18. Nontraditional instruction (NTI) functions much better with access to high speed internet. About 25,600 school age children in Jefferson County do not have access to high speed internet. The map below is broken into 6 areas based on public use microdata geographies. Unfortunately, this is the lowest geographic level of detail we can get with Census microdata for school-age childen.

```{r, message = FALSE}
##Section on Children

#Recode values so that 1 indicates not having interent access
#This makes it easier to get a raw count on number of kids without high speed access
df_ch <- df_na %>%
  filter(AGE > 4 & AGE < 19 & YEAR == 2018) %>%
  mutate(hint = case_when(
    hspd_int == 1 ~ 0,
    hspd_int == 0 ~ 1,
    TRUE ~ NA_real_
  ))

svy_df <- svydesign(ids = ~ 1, weights = ~PERWT, data = df_ch)

##Making a map
int_tbl <- svyby(~hint, ~YEAR + PUMA, design = svy_df, svymean)

int_tbl_count <- svyby(~hint, ~YEAR + PUMA, design = svy_df, svytotal)

ky_shp <- readOGR("ipums_internet_access/cb_2016_21_puma10_500k", layer = "cb_2016_21_puma10_500k", GDAL1_integer64_policy = TRUE, verbose = FALSE)
ky_shp@data$PUMA <- as.numeric(as.character(ky_shp@data$PUMACE10))
ky_sf <- st_as_sf(ky_shp)

jeff_co_sf <- ky_sf %>% 
  filter(ky_sf$PUMA %in% c("1701", "1702", "1703", "1704", "1705", "1706"))

int_puma <- tibble(
  PUMA = int_tbl$PUMA,
  int_per = int_tbl$hint * 100,
  int_num = formattable::comma(round(int_tbl_count$hint, -2), digits = 0)
)

jeff_co_sf <- full_join(jeff_co_sf, int_puma, by = "PUMA")

text_scale <- 1

ggplot(jeff_co_sf) + 
  geom_sf(aes(fill=int_per), color = "#ffffff") +
  geom_sf_label(aes(label = int_num), family = "Montserrat", fontface = "bold", size = 8) +
  #scale_fill_gradient(low = "#0e4a99", high = "#f58021", name = "Percent") +
  scale_fill_gradient(low = "#323844", high = "#d63631", name = "Percent") +
  theme_bw() +
  theme(text = element_text(family = "Montserrat"),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        
        plot.caption     = element_text(size = 18 * text_scale, lineheight = .5),
        legend.title     = element_text(size = 24 * text_scale),
        legend.text      = element_text(size = 20 * text_scale,
                                        margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),
        plot.title = element_text(size = 32 * text_scale, lineheight = .5,
                                  margin = margin(b = 0.4 * text_scale, unit = "cm"))) +
  labs(title = "Children ages 5-18 in households without
                High Speed Internet Access",
       caption = "Map is shaded by the percent of children without access in each 
                  Public Use Microdata Area. The number of children without access 
                  is given by the label rounded to the nearest 100. \n
                  Greater Louisville Project Analysis of Census Microdata from IPUMs") +
  theme(
    panel.background = element_rect(fill = "transparent",colour = NA),
    plot.background = element_rect(fill = "transparent",colour = NA),
    legend.background = element_rect(fill = "transparent",colour = NA),
    legend.box.background = element_rect(fill = "transparent",colour = NA),
    legend.key = element_rect(fill = "transparent",colour = NA))
```


### Metro Council Districts {.panelset}

If we expand our focus to all children ages 0-17, we can get data at finer levels of geography. The map below shows the percent of children ages 0-17 who lack either high-speed internet or a computer at home. Most of these children are school age, though the data also includes some infants and toddlers who are not in school.

<!-- ::: {.tab} -->
<!-- <button class="tablinks" onclick="unrolltab(event, 'no-district-labels')">No District Labels</button> -->
<!-- <button class="tablinks" onclick="unrolltab(event, 'district-labels')">District Labels</button> -->

#### No District labels {-}

```{r, message = FALSE}
map_district <- st_read("ipums_internet_access/Council_Districts", quiet =T)
child_internet <- read_csv("ipums_internet_access/child_internet.csv", col_types = "nnnn")

load("ipums_internet_access/district_label_points.RData")

map_district %<>% select(district = coundist) %>%
  left_join(child_internet, by = "district") %>%
  mutate(no_int = 100 - percent_internet)

# Replicate binary decision tree to determine most-interior point of polygons
# buffers <- c()
# 
# for(d in 1:26) {
#   buff_max = -0.06
#   buff_min = 0
#   this_buffer = buff_min
#   this_step = buff_max
#   current_resolution = 11
#   
#   while(current_resolution > 10){
#   
#     #browser()
#     # Buffer inside the polygon using this_buffer
#     temp_sf <- st_buffer(map_district[d,], dist = this_buffer, singleSide = T) 
#   
#     # Calculate area of polygon
#     temp_area = st_area(temp_sf) %>% as.numeric()
#     
#     # If remaining area > 0, enlarge buffer by going away from 0. 
#     #   Also record most recent correct buffer and area produced by buffer.
#     # If remaining area is 0, reduce buffer by going toward 0.
#     if (temp_area > 0) {
#       current_result = this_buffer
#       current_resolution = temp_area
#       
#       this_buffer = this_buffer + this_step
#     } else {
#       this_buffer = this_buffer - this_step
#     }
#     
#     # Cut search step in half
#     this_step = this_step / 2
#   }
#   
#   buffers <- c(buffers, current_result)
#   
# }

text_scale <- 1

ggplot(map_district) + 
  geom_sf(aes(fill=no_int), color = "#ffffff") +
  #geom_sf_text(aes(label = district), family = "Montserrat Bold", fontface = "bold", size = 6, color = "#ffffff",
               #fun.geometry = function(x) st_buffer(x, dist = buffers, singleSide = T) %>% st_point_on_surface()) +
  #scale_fill_gradient(low = "#0e4a99", high = "#f58021", name = "Percent") +
  scale_fill_gradient(low = "#323844", high = "#d63631", name = "Percent") +
  theme_bw() +
  theme(text = element_text(family = "Montserrat"),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        
        plot.caption     = element_text(size = 18 * text_scale, lineheight = .5),
        legend.title     = element_text(size = 24 * text_scale),
        legend.text      = element_text(size = 20 * text_scale,
                                        margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),
        plot.title = element_text(size = 32 * text_scale, lineheight = .5, hjust = 0.5,
                                  margin = margin(b = 0.4 * text_scale, unit = "cm"))) +
  labs(title = "Children ages 0-17 in households without
                High Speed Internet Access and a computer",
       caption = "Map is shaded by the percent of children without access in each 
                  Metro Council District. The number of children without internet 
                  or without a computer is given by the label rounded to the nearest 100. \n
                  Greater Louisville Project Analysis of Census ACS data.") +
  theme(
    panel.background = element_rect(fill = "transparent",colour = NA),
    plot.background = element_rect(fill = "transparent",colour = NA),
    legend.background = element_rect(fill = "transparent",colour = NA),
    legend.box.background = element_rect(fill = "transparent",colour = NA),
    legend.key = element_rect(fill = "transparent",colour = NA))

output_table <- map_district %>% 
  transmute(
    District = district, 
         "Percent without access" = scales::percent(100 - percent_internet, scale = 1, accuracy = 0.1),
         "Children with access" = scales::comma(child_internet, accuracy = 1),
         "Children without access" = scales::comma(total_child - child_internet, accuracy = 1)) %>%
  sf::st_drop_geometry()

kbl(output_table, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(height = "300px")

```

#### District Labels {-}

```{r}
ggplot(map_district) + 
  geom_sf(aes(fill=no_int), color = "#ffffff") +
  geom_sf_text(data = district_label_points, 
               aes(label = district), family = "Montserrat Bold", fontface = "bold", size = 6, color = "#ffffff") +
  #scale_fill_gradient(low = "#0e4a99", high = "#f58021", name = "Percent") +
  scale_fill_gradient(low = "#323844", high = "#d63631", name = "Percent") +
  theme_bw() +
  theme(text = element_text(family = "Montserrat"),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        
        plot.caption     = element_text(size = 18 * text_scale, lineheight = .5),
        legend.title     = element_text(size = 24 * text_scale),
        legend.text      = element_text(size = 20 * text_scale,
                                        margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),
        plot.title = element_text(size = 32 * text_scale, lineheight = .5, hjust = 0.5,
                                  margin = margin(b = 0.4 * text_scale, unit = "cm"))) +
  labs(title = "Children ages 0-17 in households without
                High Speed Internet Access and a computer",
       caption = "Map is shaded by the percent of children without access in each 
                  Metro Council District. The number of children without internet 
                  or without a computer is given by the label rounded to the nearest 100. \n
                  Greater Louisville Project Analysis of Census ACS data.") +
  theme(
    panel.background = element_rect(fill = "transparent",colour = NA),
    plot.background = element_rect(fill = "transparent",colour = NA),
    legend.background = element_rect(fill = "transparent",colour = NA),
    legend.box.background = element_rect(fill = "transparent",colour = NA),
    legend.key = element_rect(fill = "transparent",colour = NA))


kbl(output_table, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(height = "300px")

# map_district %<>%
#   mutate(hover = paste("District", district))

# library(plotly)
# 
# plotly::plot_ly(stroke = I("white")) %>%
#   add_sf(data = map_district, 
#          color = ~percent_internet, 
#          split = ~district,
#          colors = c("#d63631", "#323844"),
#          alpha = 1)



```

## Internet as a Public Utility

The lack of high speed internet access in Louisville is part of a broader trend across the United States of continuing to treat home internet as something that is 'nice to have' instead of something that is necessary to fully take part in modern society. In general, the U.S. leaves broadband infrastructure to private companies who will not build out infrastructure to areas that aren't profitable. An exception to this trend in Chatanooga, TN, where [the electric utility is also an Internet Service Provider](https://tech.co/news/chattanooga-fastest-internet-usa-2018-08). The lack of internet acess in Louisville (and throughout the U.S) has [severe consequences](https://www.theatlantic.com/technology/archive/2020/08/virtual-learning-when-you-dont-have-internet/615322/) including exacerbating inequality (both racial and economic) and slower overall economic growth. 

### Local Efforts

- Jefferson County Public Schools have distributed hotspots and chromebooks to try to complete NTI. 
- Kentucky is investing $8 million to [subsidize internet access for low-income students](https://wfpl.org/kentucky-to-invest-in-broadband-access-for-low-income-students/)
 
```{r, eval = FALSE}
# png("rankings_graph.png", 1500, 1200, res = 200)
# plt1
# dev.off
# 
# png("int_access_graph.png", 1600, 1200, res = 200)
# plt_int
# dev.off
# 
# png("int_poverty.png", 1600, 1200, res = 200)
# plt_pov
# dev.off
# 
# png("int_race.png", 1600, 1200, res = 200)
# plt_race
# dev.off
# 
# png("int_age.png", 1600, 1200, res = 200)
# plt_age
# dev.off
```

For more local data and analysis please visit the [Greater Louisville Project](https://greaterlouisvilleproject.org/)

<!--chapter:end:internet_report.Rmd-->

---
title: "Housing Instability in Louisville"
author: "Greater Louisville Project"
date: '2020-12-08'
output:
  html_document:
    self_contained: no
    toc: yes
    toc_float: yes
    code_folding: hide
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), 'index.html')) })
---

# Housing Instability in Louisville

## Introduction

This recreates the Urban Institute's [Emergency Rental Assistance Priority Index](https://www.urban.org/features/where-prioritize-emergency-rental-assistance-keep-renters-their-homes) for Louisville. The original index compares Louisville to the rest of Kentucky. At Greater Louisville Project, we think the more appropriate comparison is to our other peer cities. While the maps below show Louisville, the index values are based on a comparison to all census tracts in the core counties of our peer cities.

Greater Louisville Project has also aggregated the data up to the metro council district level. That data is available in both maps and tables.

In addition to the indexes, the indicators that make up the indexes are also mapped below. Navigation is based on tabs, so clicking on the small blue titles brings up the map related to each title.

### Methods and Definitions

To produce an index with multiple indicators on different scales we used z-scores, which are a measure of how far away from average an observation is. For example, if looking at unemployment, we start with the unemployment rate in all tracts and the score for an individual tract is the number of standard deviations it is away from the average tract.

Data is from the Urban Institute's [Emergency Rental Assistance Priority Index](https://www.urban.org/features/where-prioritize-emergency-rental-assistance-keep-renters-their-homes) and in most cases is tract level census data from 2018. The low income jobs lost to Covid is an [Urban Institute constructed indicator](https://www.urban.org/features/where-low-income-jobs-are-being-lost-covid-19). Complete details on the indicators can be found in the [technical appendix](https://www.urban.org/sites/default/files/2020/08/24/where_to_prioritize_emergency_rental_assistance_to_keep_renters_in_their_homes_technical_appendix.pdf), but they are summarized here for convenience.

#### Housing Instability Index

-   Poverty: Under the poverty line in the last 12 months
-   Percent Renting: The percent of households in the area who rent
-   Cost Burdened: Households making less than 35,000 and paying more than 50% of their income in rent
-   Overcrowding: Households renting and with more than 1.5 people per room.
-   Unemployed: In the labor force but not currently employed.

#### Covid Index

-   Health Insurance: Based on the noninstitutionalized population ages 19-64.
-   Low Income Job Loss from Covid: Estimated jobs lost to Covid based on previous [Urban Institute Study](https://www.urban.org/features/where-low-income-jobs-are-being-lost-covid-19)

#### Equity Index

-   Percent Persons of Color: Percent of people in the area who identify as persons of color
-   Extremely Low Income: Renter occupied household making less than 30 percent of area median income
-   Public Assistance: Percent receiving some form of public assistance like SNAP or TANF
-   Foreign Born: Percent born outside the U.S.

```{r setup3, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

knitr::opts_chunk$set(dev.args=list(bg="transparent"))

# set up fonts
library(showtext)
showtext_auto()

font_add("Montserrat", "Black_wealth/Montserrat/Montserrat-Regular.ttf")
font_add("Montserrat Bold", "Black_wealth/Montserrat/Montserrat-SemiBold.ttf")
```

```{r xaringan-panelset3, echo=FALSE}
xaringanExtra::use_panelset()
```

```{r, eval=FALSE}
library(glpdata)
library(glptools)

save(home_loan_county, home_loan_tract,
     HPI_county, HPI_zip,
     map_zip, 
     clean_acs_micro,
     file = "glptools_exports.RData")
```

```{r}
library(tidyverse)
library(rgdal)
library(sf)
library(viridis)
library(magrittr)

load("housing_data/glptools_exports.RData")

df <- read_csv("housing_data/housing_index_raw.csv")

# Filter to just peers
df_peer <- df %>% 
  filter(county_fips %in% c("1073", "18097", "21111", "26081", "29095", "29189",
                            "29510", "31055", "37081", "37119", "39049", "39061",
                            "40109", "40143", "45045", "47037", "47093", "47157")) %>%
  select(-contains("z_score"), -contains("index")) #drop index and z_score terms so we can recreate them

# Make z scores
make_z <- function(x){
  x <- (x - mean(x)) / sd(x)
}

df_z <- df_peer %>%
  mutate(across(where(is.numeric), make_z, .names = "z_{.col}"))

df_index <- df_z %>%
  mutate(
    housing_instability_index = z_perc_poverty_12mnth * .2 + z_perc_renters * .2 + z_perc_cost_burdened_under_35k * .2 + z_perc_overcrowding_renter_1.50_or_more * .2 + z_perc_unemployed_laborforce * .2,
    covid_index = z_perc_no_hinsure * .5 + z_perc_low_income_jobs_lost * .5,
    equity_index = z_perc_person_of_color * .5 + z_perc_30hamfi * .167 + z_perc_public_assistance * .167 + z_perc_foreign_born * .167,
    overall_index = housing_instability_index * .5 + covid_index * .1 + equity_index * .4
  )
```

## Rental Insecurity Index{.panelset}

```{r rental_insecurity_index}
jfco_shp <- readOGR("housing_data/JC Tracts", layer = "JC Tracts",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

jfco_sf <- st_as_sf(jfco_shp) %>%
  mutate(GEOID = str_sub(GEO_ID, start = -11))

jfco_index <- df_index %>% 
  filter(county_fips == "21111") 

# Urban institute includes a greyed out flag for tracts without enough data
# It's easier to set the values to NA because the graphing framework has the ability to easily assign NA a different color
jfco_index <- jfco_index %>%
  mutate(across(where(is.numeric), ~if_else(jfco_index$grayed_out == 1, NA_real_, .)))
         
jfco_sf <- full_join(jfco_sf, jfco_index, by = "GEOID")

# Transform the percents
mult100 <- function(x){
  x <- x * 100
}

jfco_sf <- jfco_sf %>%
  mutate(across(starts_with("perc_"), mult100))

make_map <- function(indicator, title = "", legend = "", caption = "", no_legend = FALSE, vir_dir = 1){
  plt <- ggplot(jfco_sf) + 
  geom_sf(aes(fill={{ indicator }} )) +
  # scale_fill_gradient(low = "#323844", high = "#d63631", name = "Percent") +
  scale_fill_viridis(na.value = "grey", name = legend, direction = vir_dir) +
  theme_bw(base_size = 22) +
  theme(plot.caption = element_text(lineheight = .5)) +
  theme(text = element_text(family = "Montserrat"),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = title,
       caption = caption)
  
  if (no_legend == TRUE){
    plt <- plt + theme(legend.position = "none")
  }
  
  plt <- plt +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA))
  
  return(plt)
}

make_map(overall_index, title = "Rental Insecurity Index", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher rental insecurity. \n This is the Urban Institute's Emergency Rental Assistance Priority Index modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

You can flip through the tabs below to see each of the three subindexes that make up the overall rental index.

### Housing Instability Subindex

-   Share of people living in poverty
-   Share of renter-occupied housing units
-   Share of severely cost-burdened low-income renters
-   Share of severely overcrowded households
-   Share of unemployed people

```{r housing_instability_subindex}
make_map(housing_instability_index, title = "Housing Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher housing instability. \n This is the Urban Institute's Housing Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Covid 19 Impact Subindex

-   Share of adults without health insurance
-   Share of low-income jobs lost to Covid-19

```{r covid_19_impact_subindex}
make_map(covid_index, title = "Covid Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher covid instability. \n This is the Urban Institute's Covid Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Equity Subindex

-   Share of people of color
-   Share of extremely low-income renter households
-   Share of households receiving public assistance
-   Share of people born outside the United States

```{r equity_subindex}
make_map(equity_index, title = "Equity Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher prioritization based on equity. \n This is the Urban Institute's Equity subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

## Housing Instability Indicators {.panelset}

### Poverty

```{r poverty}
make_map(perc_poverty_12mnth, title = "Poverty", 
         legend = "Percent", 
         caption = "Percent of each census tract that is in poverty. \n Data from Urban Institute.")
```

### Percent Renting

```{r renting}
make_map(perc_renters, title = "Percent of Renter Occupied Housing Units", 
         legend = "Percent", 
         caption = "Percent of each tract that rents. \n Data from Urban Institute")
```

### Cost-burdened housholds

```{r cost_burdened}
make_map(perc_cost_burdened_under_35k, title = "Costburdened Households making under 35k", 
         legend = "Percent", 
         caption = "Percent of households making less than 35,000 and paying more than 50% of their income in rent. \n Data from Urban Institute")
```

### Overcrowding

```{r overcrowding}
make_map(perc_overcrowding_renter_1.50_or_more, title = "Overcrowding in Rental Housing", 
         legend = "Percent", 
         caption = "Percent of households renting and with more than 1.5 people per room. \n Data from Urban Institute")
```

### Unemployed

```{r unemployment}
make_map(perc_unemployed_laborforce, title = "Unemployment", 
         legend = "Percent", 
         caption = "Percent of people unemployed but still in the labor force (actively seeking work). \n Data from Urban Institute")
```

## Covid Indicators {.panelset}

### No Health Insurance

```{r no_health_insurance}
make_map(perc_no_hinsure, title = "No Health Insurance", 
         legend = "Percent", 
         caption = "Percent without health insurance. \n Data from Urban Institute")
```

### Low Income Jobs Lost to Covid

```{r low_income_job_loss}
make_map(perc_low_income_jobs_lost, title = "Low Income Jobs Lost to Covid", 
         legend = "Percent", 
         caption = "Estimate from the Urban Institute based on job categories in the each tract. \n Data from Urban Institute")
```

## Equity Index {.panelset}

### Percent PoC

```{r people_of_color}
make_map(perc_person_of_color, title = "Percent Persons of Color", 
         legend = "Percent", 
         caption = "Percent of persons in the area who identify as persons of color. \n Data from Urban Institute")
```

### Extremely Low Income

```{r extremely_low_income}
make_map(perc_30hamfi, title = "Extremely Low Income", 
         legend = "Percent", 
         caption = "Renter occupied household making less than 30 percent of area median income. \n Data from Urban Institute")
```

### Public Assistance

```{r public_assistance}
make_map(perc_public_assistance, title = "Recieving Public Assistance", 
         legend = "Percent", 
         caption = "Percent receiving some form of public assistance like SNAP or TANF. \n Data from Urban Institute")
```

### Foreign Born

```{r foreign_born}
make_map(perc_foreign_born, title = "Foreign Born", 
         legend = "Percent", 
         caption = "Percent born outside the U.S. \n Data from Urban Institute")
```

## Peer City Data {.panelset}

Peer city data is available for the housing stability subindex.

```{r}
# Ranking graph function
ranking <- function(df, var, plot_title = "",
                    year = NULL, sex = "total", race = "total",
                    order = "Descending",
                    y_title = "Percent", caption_text = "", subtitle_text = "",
                    bar_label = TRUE, sigfig = 3, accuracy = 0.1,
                    label_function, alternate_text = NULL,
                    ranking_colors = TRUE, text_size){
  # Copy variable var to a new column for use with the '$' operator
  var <- dplyr:::tbl_at_vars(df, vars(!!enquo(var)))
  df$var <- df[[var]]
  # Filter to sex, race, and year
  if ("sex" %in% names(df)) df <- df[df$sex == sex,]
  if ("race" %in% names(df)) df <- df[df$race == race,]
  if("year" %in% names(df)) {
    if (is.null(year)) year <- max(years_in_df(df, var))
    df <- df[df$year %in% year,]
    if (length(year) > 1) {
      df %<>%
        group_by_at(df %cols_in% c("MSA", "FIPS")) %>%
        summarise(var = mean(var, na.rm = TRUE)) %>%
        ungroup()
    }
  }
  # Add peer data if not already present
  # if (df_type(df) %in% c("FIPS", "MSA") & "current" %not_in% names(df)) df %<>% pull_peers(add_info = T)
  
  # Sort according to order parameter
  if (order %in% c("descending", "Descending")) df %<>% arrange(desc(var))
  if (order %in% c("ascending", "Ascending"))   df %<>% arrange(var)
  df %<>% filter(!is.na(var))
  # Create numbered city labels for left side of graph
  df %<>%
    mutate(
      rank = row_number(),
      names = paste0(rank, ". ", city))
  # Set bar colors
  if (ranking_colors) {
    # color_values <- c("#96ca4f", "#ffd600", "#db2834")
    # color_names <- c("green", "yellow", "red")
    # if (order %in% c("descending", "Descending")) {color_names  = rev(color_names)}
    # 
    # breaks <- classInt::classIntervals(na.omit(df$var), 3, style = "jenks")
    # df$color <- NA
    # df$color[df$var <= breaks$brks[2]] <- color_names[1]
    # df$color[df$var > breaks$brks[2] & df$var <= breaks$brks[3]] <- color_names[2]
    # df$color[df$var > breaks$brks[3]] <- color_names[3]
    
    color_values <- c("#d63631", "#323844")
    color_names <- c("gray", "red")
    
    df$color <- "red"
    df$color[df$city == "Louisville"] <- "gray"
  } else {
    df$color <- "blue"
    color_values <- "#f58021"
    color_names <- "blue"
  }
  if (order %in% c("descending", "Descending")) color_values = rev(color_values)
  # Create numeric labels
  # Create numeric labels
  if (!missing(label_function)) {
    label_text <- df$var %>% signif(sigfig) %>% label_function()
  } else if (y_title == "Dollars") {
    if(mean(df$var, na.rm = TRUE) > 10000) {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = accuracy, scale = .001, suffix = "k")
    } else {
      label_text <- df$var %>% signif(sigfig) %>% scales::dollar(accuracy = .01)
    }
  } else if (stringr::str_detect(y_title, "Percent")) {
    label_text <- df$var %>% signif(sigfig) %>% scales::percent(accuracy = accuracy, scale = 1, suffix = "%")
  } else {
    label_text <- df$var %>% signif(sigfig) %>% scales::comma(accuracy = accuracy)
  }

  # Set text format, highlight and italicise Louisville text, highlight Louisville bar
  df$textcolor <- "#000000"
  df$textcolor[df$city == "Louisville"] <- "#000000"
  
  df$textfont <- "Montserrat"
  df$textfont[df$city == "Louisville"] <- "Montserrat Bold"
  
  label_color_names <- c("white", "black")
  label_color_values <- c("#000000", "#ffffff")
  
  df$label_color <- "white"
  df$label_color[df$city == "Louisville"] <- "black"
  #df$linecolor <- "#ffffff"
  #df$linecolor[df$city == "Louisville"] <- "#00a9b7"
  df$lou <- if_else(df$city == "Louisville", 1, 0)
  df$text_alignment <- 1.1
  if (!is.null(alternate_text)) df$text_alignment[df$rank %in% alternate_text] <- -0.1
  ### PLOT GRAPH
  
  # Initial plot
  p <- ggplot(data = df,
              aes(x = factor(names, levels = rev(names)),
                  y = var,
                  fill  = factor(color, levels = color_names, ordered = TRUE)))
  p <- p + guides(fill = FALSE, color = FALSE)
  # Add bars
  p <- p +
    geom_bar(stat = "identity",
             size = text_size) +
    coord_flip() +
    ggthemes::theme_tufte()
  p <- p + scale_fill_manual(values = color_values)
  #p <- p + scale_color_manual(values = c("#ffffff", "#00a9b7"))
  # Add features
  title_scale <- min(1, 48 / nchar(plot_title))
  p <- p + theme(text = element_text(family = "Montserrat"),
                 plot.title = element_text(size = 14 * title_scale * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
                 axis.text.y = element_text(hjust = 0,
                                            size = 10 * text_size, 
                                            color = rev(df$textcolor),
                                            family = rev(df$textfont)),
                 axis.title.x = element_text(size = 10 * text_size),
                 axis.ticks = element_blank(),
                 axis.text.x = element_blank(),
                 plot.caption = element_text(size = 5 * text_size, lineheight = 0.5))
  if(subtitle_text != ""){
    p <- p + theme(plot.subtitle = element_text(hjust = 0.5, size = 5 * text_size)) +
      labs(subtitle = subtitle_text)
  }
  # Add numeric labels to bars based on bar_label parameter
  if (y_title != "" & bar_label) {
    p <- p + geom_text(aes(label = label_text, 
                           hjust = text_alignment, 
                           color = factor(label_color),
                           family = textfont),
                       size = 4.5 * text_size) +
       scale_colour_manual(values=c("#000000", "#ffffff"))
    }
  # Add vertical line to the left side of the bars based on the h_line parameter
  if (min(df$var, na.rm = TRUE) < 0) p <- p + geom_hline(yintercept = 0, linetype = "longdash", size = 2)
  # Add remaining text
  p <- p + labs(title = plot_title, y = y_title,
                x = "", caption = caption_text)
  
  p <- p +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA))
  
  p
}

```

### Cost Burdened Renters

```{r cost_burdened_renters_ranking}
#Data was pulled in Python file get_data.py and written to .csv
df <- read_csv("housing_data/low_income_renters.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R

# Calculate percent of households making under 35k who pay more than 50% of their
# income on rent
df <- df %>%
  # select ACS table variables w/ attached GEOID
  select(
    NAME,
    # These are all the peolpe making under 35k (denominator)
    B25074_002E,
    B25074_011E,
    B25074_020E,
    # These are all the people making under 35k who pay more than 50% of their income on rent (numerator)
    B25074_009E,
    B25074_018E,
    B25074_027E,
    # These are the people making under 35k for whom this metric wasn't computed
    # and they therefore need to be subtracted from the denominator
    B25074_010E,
    B25074_019E,
    B25074_028E
  )  %>%
  #rename both county and city to just St. Louis
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  #use summarize across instead to save space and make reusable in a function
  summarize(
    B25074_002E = sum(B25074_002E),
    B25074_011E = sum(B25074_011E),
    B25074_020E = sum(B25074_020E),
    B25074_009E = sum(B25074_009E),
    B25074_018E = sum(B25074_018E),
    B25074_027E = sum(B25074_027E),
    B25074_010E = sum(B25074_010E),
    B25074_019E = sum(B25074_019E),
    B25074_028E = sum(B25074_028E)
  ) %>%
  # create cost burden variable w/ calculation
  mutate(
    perc_cost_burdened_under_35k = (B25074_009E + B25074_018E + B25074_027E) /
      (
        B25074_002E + B25074_011E + B25074_020E - B25074_010E - B25074_019E -
          B25074_028E
      ),
    #cd add
    perc_cost_burdened_under_35k =
      if_else(
        B25074_002E + B25074_011E + B25074_020E == 0,
        0,
        perc_cost_burdened_under_35k
      )
  )

# Clean up for graph
df <- df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "Greensboro",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "Kansas City",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indiana` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "Charlotte",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_cost_burdened_under_35k = 100 * perc_cost_burdened_under_35k) 

plt_cost_burdened <- ranking(df, "perc_cost_burdened_under_35k", text_size = 2, order = "ascending",
                             plot_title = "Cost Burdened Renters in Households Making Under 35k ")

plt_cost_burdened
```

### Overcrowding

```{r overcrowding_ranking}
#Data was pulled in Python file get_data.py and written to .csv
oc_df <- read_csv("housing_data/overcrowding.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R

oc_df <- oc_df %>%
  # select ACS table variables w/ attached GEOID
  select(NAME, B25014_013E, B25014_012E, B25014_008E)  %>%
  #rename both county and city to just St. Louis
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  summarize(across(where(is.numeric), sum)) %>%
   # create cost burden variable w/ calculation
  mutate(perc_overcrowding_renter_1.50_or_more = ((B25014_012E + B25014_013E) / B25014_008E),
         perc_overcrowding_renter_1.50_or_more = 
           if_else(B25014_008E == 0, 0, perc_overcrowding_renter_1.50_or_more))

# Clean up for graph
oc_df <- oc_df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "Greensboro",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "Kansas City",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indiana` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "Charlotte",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_overcrowding_renter_1.50_or_more = 100 * perc_overcrowding_renter_1.50_or_more) 

plt_oc <- ranking(oc_df, "perc_overcrowding_renter_1.50_or_more", text_size = 2, order = "ascending",
                             plot_title = "Overcrowding")

plt_oc
```

### Unemployment

```{r unemployment_ranking}
#Data was pulled in Python file get_data.py and written to .csv
un_df <- read_csv("housing_data/unemployed.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R
un_df <- un_df %>%
  # select ACS table variables w/ attached GEOID
  select(B12006_055E, B12006_050E, B12006_011E, B12006_006E, B12006_022E, B12006_017E, B12006_033E, B12006_028E, B12006_044E, B12006_039E, B12006_053E, B12006_048E, B12006_009E, B12006_004E, B12006_020E, B12006_015E, B12006_031E, B12006_026E, B12006_042E, B12006_037E, NAME) %>%
  # collapse St. Louis into one
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  summarize(across(where(is.numeric), sum)) %>%
  # create unemployed variable w/ calculation
  mutate(perc_unemployed_laborforce = ((B12006_055E + B12006_050E + B12006_011E + B12006_006E + B12006_022E + B12006_017E + B12006_033E + B12006_028E + B12006_044E + B12006_039E) / (B12006_053E + B12006_048E + B12006_009E + B12006_004E + B12006_020E + B12006_015E + B12006_031E + B12006_026E + B12006_042E + B12006_037E)),
         perc_unemployed_laborforce = 
           if_else(B12006_053E + B12006_048E + B12006_009E + B12006_004E + B12006_020E + B12006_015E + B12006_031E + B12006_026E + B12006_042E + B12006_037E == 0, 0,
                   perc_unemployed_laborforce))

# Clean up for graph
un_df <- un_df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "Greensboro",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "Kansas City",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indiana` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "Charlotte",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_unemployed_laborforce = 100 * perc_unemployed_laborforce) 

plt_un <- ranking(un_df, "perc_unemployed_laborforce", text_size = 2, order = "ascending",
                             plot_title = "Unemployed")

plt_un
```

### Share renting

```{r renters_ranking}
#Data was pulled in Python file get_data.py and written to .csv
sr_df <- read_csv("housing_data/share_renting.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R
sr_df <- sr_df %>%
  # select ACS table variables w/ attached GEOID
  select(B25003_003E, B25003_001E, NAME) %>%
  # collapse St. Louis into one
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  summarize(across(where(is.numeric), sum)) %>%
  # create perc_renters variable w/ calculation
  mutate(perc_renters = (B25003_003E / B25003_001E),
         perc_renters = if_else(B25003_001E == 0, 0, perc_renters),
         num_renters = B25003_003E)

# Clean up for graph
sr_df <- sr_df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "Greensboro",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "Kansas City",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indiana` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "Charlotte",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_renters = 100 * perc_renters) 

plt_sr <- ranking(sr_df, "perc_renters", text_size = 2, order = "ascending",
                             plot_title = "Percent Renters")

plt_sr
```

### Poverty

```{r poverty_ranking}
#Data was pulled in Python file get_data.py and written to .csv
pv_df <- read_csv("housing_data/poverty.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R
pv_df <- pv_df %>%
  # select ACS table variables w/ attached GEOID
select(C17002_002E, C17002_003E, C17002_001E, NAME) %>%  
  # collapse St. Louis into one
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  summarize(across(where(is.numeric), sum)) %>%
  # create poverty variable w/ calculation
  mutate(perc_poverty_12mnth = ((C17002_002E + C17002_003E) / C17002_001E),
         perc_poverty_12mnth = 
           if_else(C17002_001E == 0, 0, perc_poverty_12mnth))

# Clean up for graph
pv_df <- pv_df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "Greensboro",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "Kansas City",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indiana` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "Charlotte",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_poverty_12mnth = 100 * perc_poverty_12mnth) 

plt_pv <- ranking(pv_df, "perc_poverty_12mnth", text_size = 2, order = "ascending",
                             plot_title = "Poverty")

plt_pv
```

## Metro Council District Maps {.panelset}

### Rental Insecurity Index

```{r rental_insecurity_index_council}
# Read in cross walk
tract_to_district <- read_csv("housing_data/district_tract_crosswalk.csv") %>%
  mutate(tract = as.character(tract))

# Join to data
district_level <- df_index %>%
  rename(tract = GEOID) %>%
  # Remove airport to avoid dividing by zero
  filter(tract!= "21111980100") %>%
  # join crosswalk data to dataframe
  left_join(tract_to_district, by = "tract") %>%   
  # Group by district
  group_by(district) %>%
  # join crosswalk data to dataframe
  summarise(across(where(is.numeric), ~sum(. * total)), .groups = "drop")

# Shape files
metro_shp <- readOGR("housing_data/Council_Districts", layer = "council_districts",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

metro_sf <- st_as_sf(metro_shp) %>%
  rename(district = coundist)

metro_sf <- full_join(metro_sf, district_level, by = "district")

# Transform the percents
mult100 <- function(x){
  x <- x * 100
}

metro_sf <- metro_sf %>%
  mutate(across(starts_with("perc_"), mult100))

load("housing_data/district_label_points.RData")

district_label_points %<>%
  mutate(
    x = unname(st_coordinates(.)[,1]),
    y = unname(st_coordinates(.)[,2]))

write_csv(st_drop_geometry(metro_sf), "metro_data.csv")

metro_map <- function(indicator, title = "", legend = "", caption = "", no_legend = FALSE){

  plt <- ggplot(metro_sf) + 
    geom_sf(aes(fill={{ indicator }} )) +
    # Add District labels 
    shadowtext::geom_shadowtext(data = district_label_points,
                                aes(x = x, y=y, label = district),
                                family = "Montserrat Bold", size = 8,
                                color = "white", bg.color="black") +
    #geom_sf(data = district_label_points, aes(color =district)) +
    #geom_sf_text(aes(label = district), color = "white") +
    #geom_sf_text(aes(label = district), size = 6, color = "#ffffff",
    #             fun.geometry = function(x) st_buffer(x, dist = buffers, singleSide = T) %>% st_point_on_surface()) +
    # scale_fill_gradient(low = "#323844", high = "#d63631", name = legend) +
    scale_fill_viridis(na.value = "grey", name = legend) +
    theme_bw(base_size = 22, base_family = "Montserrat") +
    theme(plot.caption = element_text(lineheight = .5)) +
    theme(panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.border = element_blank()) +
    labs(title = title,
         caption = caption)
  
  if (no_legend == TRUE){
    plt <- plt + theme(legend.position = "none")
  }
  
  plt <- plt +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA))
  
  return(plt)
}

metro_map(overall_index, title = "Rental Insecurity Index", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher rental insecurity. \n This is the Urban Institute's Emergency Rental Assistance Priority Index modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Housing Instability Subindex

```{r housing_instability_subindex_council}
metro_map(housing_instability_index, title = "Housing Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher housing instability. \n This is the Urban Institute's Housing Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Covid 19 Impact Subindex

```{r covid_19_impact_subindex_council}
metro_map(covid_index, title = "Covid Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher covid instability. \n This is the Urban Institute's Covid Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Equity Subindex

```{r equity_subindex_council}
metro_map(equity_index, title = "Equity Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "Lighter shades indicate higher prioritization based on equity. \n This is the Urban Institute's Equity subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index",
         no_legend = TRUE)
```

### Poverty

```{r poverty_council}
metro_map(perc_poverty_12mnth, title = "Poverty", 
         legend = "Percent", 
         caption = "Percent of each census tract that is in poverty. \n Data from Urban Institute.")
```

### Percent Renting

```{r renting_council}
metro_map(perc_renters, title = "Percent of Renter Occupied Housing Units", 
         legend = "Percent", 
         caption = "Percent of each tract that rents. \n Data from Urban Institute")
```

### Cost-burdened housholds

```{r cost_burdened_council}
metro_map(perc_cost_burdened_under_35k, title = "Costburdened Households making under 35k", 
         legend = "Percent", 
         caption = "Percent of households making less than 35,000 and paying more than 50% of their income in rent. \n Data from Urban Institute")
```

### Overcrowding

```{r overcrowding_council}
metro_map(perc_overcrowding_renter_1.50_or_more, title = "Overcrowding in Rental Housing", 
         legend = "Percent", 
         caption = "Percent of households renting and with more than 1.5 people per room. \n Data from Urban Institute")
```

### Unemployed

```{r unemployed_council}
metro_map(perc_unemployed_laborforce, title = "Unemployment", 
         legend = "Percent", 
         caption = "Percent of people unemployed but still in the labor force (actively seeking work). \n Data from Urban Institute")
```

### No Health Insurance

```{r no_health_insurance_council}
metro_map(perc_no_hinsure, title = "No Health Insurance", 
         legend = "Percent", 
         caption = "Percent without health insurance. \n Data from Urban Institute")
```

### Low Income Jobs Lost to Covid

```{r low_income_job_loss_council}
metro_map(perc_low_income_jobs_lost, title = "Low Income Jobs Lost to Covid", 
         legend = "Percent", 
         caption = "Estimate from the Urban Institute based on job categories in the each tract. \n Data from Urban Institute")
```

### Percent PoC

```{r people_of_color_council}
metro_map(perc_person_of_color, title = "Percent Persons of Color", 
         legend = "Percent", 
         caption = "Percent of persons in the area who identify as persons of color. \n Data from Urban Institute")
```

### Extremely Low Income

```{r extremely_low_income_council}
metro_map(perc_30hamfi, title = "Extremely Low Income", 
         legend = "Percent", 
         caption = "Renter occupied household making less than 30 percent of area median income. \n Data from Urban Institute")
```

### Public Assistance

```{r public_assistance_council}
metro_map(perc_public_assistance, title = "Recieving Public Assistance", 
         legend = "Percent", 
         caption = "Percent receiving some form of public assistance like SNAP or TANF. \n Data from Urban Institute")
```

### Foreign Born

```{r foreign_born_council}
metro_map(perc_foreign_born, title = "Foreign Born", 
         legend = "Percent", 
         caption = "Percent born outside the U.S. \n Data from Urban Institute")
```

## Metro Council Tables {.panelset}

### Housing Subindex

```{r}
library(gt)

metro_house_tbl <- metro_sf %>%
  st_drop_geometry() %>%
  filter(!is.na(district)) %>%
  select(district, perc_cost_burdened_under_35k, perc_renters, perc_poverty_12mnth, perc_unemployed_laborforce, perc_overcrowding_renter_1.50_or_more, housing_instability_index) %>%
  #GT fmt_percent expects percents as decimals
  mutate(across(starts_with("perc"), ~ ./100)) %>%
  gt() %>%
  tab_header(title = "Table 1: Housing Indicators",
             subtitle = "Components of the Housing Instability Subindex") %>%
  fmt_number(columns = vars(housing_instability_index),
             n_sigfig = 2,
             suffixing = TRUE) %>%
  fmt_percent(columns = vars(perc_cost_burdened_under_35k, perc_renters, perc_poverty_12mnth, perc_unemployed_laborforce, perc_overcrowding_renter_1.50_or_more),
              decimals = 0) %>%
  cols_label(district = "Metro District",
             perc_cost_burdened_under_35k = "Cost Burdened",
             perc_renters = "Renting", 
             perc_poverty_12mnth = "Poverty", 
             perc_unemployed_laborforce = "Unemployed", 
             perc_overcrowding_renter_1.50_or_more = "Overcrowding",
             housing_instability_index = "Index") %>%
  cols_move(columns = vars(perc_cost_burdened_under_35k, perc_renters, perc_poverty_12mnth, perc_unemployed_laborforce, perc_overcrowding_renter_1.50_or_more, housing_instability_index),
            after = vars(district)) %>%
  tab_spanner(
    label = "Index",
    columns = vars(housing_instability_index)
  ) %>%
  tab_spanner(
    label = "Percent",
    columns = vars(perc_cost_burdened_under_35k, perc_renters, perc_poverty_12mnth, perc_unemployed_laborforce, perc_overcrowding_renter_1.50_or_more)
  ) %>%
  cols_align(align = "center") %>%
    tab_source_note(
    source_note = md("Greater Louisville Project")
  ) %>%
  tab_source_note(
    source_note = md("Metro Council Districts are estimated from tract level data. Data is from the Urban Institute.")
  ) %>%
  opt_row_striping(row_striping = TRUE) %>%
  opt_table_outline() %>%
  tab_options(
    table.font.size = px(12),
    table.width = pct(50)
  ) 

metro_house_tbl
```

### Covid Subindex

```{r}
metro_covid_tbl <- metro_sf %>%
  st_drop_geometry() %>%
  filter(!is.na(district)) %>%
  select(district, perc_no_hinsure, perc_low_income_jobs_lost, covid_index) %>%
  #GT fmt_percent expects percents as decimals
  mutate(across(starts_with("perc"), ~ ./100)) %>%
  gt() %>%
  tab_header(title = "Table 2: Covid Indicators",
             subtitle = "Components of the Covid Subindex") %>%
  fmt_number(columns = vars(covid_index),
             n_sigfig = 2,
             suffixing = TRUE) %>%
  fmt_percent(columns = vars(perc_no_hinsure, perc_low_income_jobs_lost),
              decimals = 0) %>%
  cols_label(district = "Metro District",
             perc_no_hinsure = "No Health Insurance", 
             perc_low_income_jobs_lost = "Covid Job Loss", 
             covid_index = "Covid Index") %>%
  cols_move(columns = vars(perc_no_hinsure, perc_low_income_jobs_lost, covid_index),
            after = vars(district)) %>%
  tab_spanner(
    label = "Index",
    columns = vars(covid_index)
  ) %>%
  tab_spanner(
    label = "Percent",
    columns = vars(perc_no_hinsure, perc_low_income_jobs_lost)
  ) %>%
  cols_align(align = "center") %>%
  tab_source_note(
    source_note = md("Greater Louisville Project")
  ) %>%
  tab_source_note(
    source_note = md("Metro Council Districts are estimated from tract level data. Data is from the Urban Institute.")
  ) %>%
  opt_row_striping(row_striping = TRUE) %>%
  opt_table_outline() %>%
  tab_options(
    table.font.size = px(12),
    table.width = pct(50)
  ) 

metro_covid_tbl
```

### Equity Index

```{r}
metro_equity_tbl <- metro_sf %>%
  st_drop_geometry() %>%
  filter(!is.na(district)) %>%
  select(district, perc_person_of_color, perc_30hamfi, perc_public_assistance, perc_foreign_born, equity_index) %>%
  #GT fmt_percent expects percents as decimals
  mutate(across(starts_with("perc"), ~ ./100)) %>%
  gt() %>%
  tab_header(title = "Table 3: Equity Indicators",
             subtitle = "Components of the Equity Subindex") %>%
  fmt_number(columns = vars(equity_index),
             n_sigfig = 2,
             suffixing = TRUE) %>%
  fmt_percent(columns = vars(perc_person_of_color, perc_30hamfi, perc_public_assistance, perc_foreign_born),
              decimals = 0) %>%
  cols_label(district = "Metro District",
             perc_person_of_color = "Person of Color", 
             perc_30hamfi = "Extremely Low Income", 
             perc_public_assistance = "Public Assistance", 
             perc_foreign_born = "Foreign Born", 
             equity_index = "Index") %>%
  cols_move(columns = vars(perc_person_of_color, perc_30hamfi, perc_public_assistance, perc_foreign_born, equity_index),
            after = vars(district)) %>%
  tab_spanner(
    label = "Index",
    columns = vars(equity_index)
  ) %>%
  tab_spanner(
    label = "Percent",
    columns = vars(perc_person_of_color, perc_30hamfi, perc_public_assistance, perc_foreign_born, equity_index)
  ) %>%
  cols_align(align = "center") %>%
  tab_source_note(
    source_note = md("Greater Louisville Project")
  ) %>%
  tab_source_note(
    source_note = md("Metro Council Districts are estimated from tract level data. Data is from the Urban Institute.")
  ) %>%
  opt_row_striping(row_striping = TRUE) %>%
  opt_table_outline() %>%
  tab_options(
    table.font.size = px(12),
    table.width = pct(50)
  ) 

metro_equity_tbl
```

## Home Mortgages

### Mortgages by geography

In 2019, about 3.8 mortgages were issued per 100 residents; however, the availability of mortgages varies greatly across the city. Two census tracts saw 0 mortgages issued in 2019, and most of West Louisville saw fewer than 1 mortgage issued per 100 residents. Meanwhile, many areas experienced a much larger availability of mortgages, especially where there is new construction around the edges of the county.

```{r mortgages_per_person}
home_loan_tract_race <- home_loan_tract %>%
  filter(year == 2019, sex == "total", race != "total") %>%
  select(tract, race, denial:rate_spread)

home_loan_tract %<>%
  filter(year == 2019, sex == "total", race == "total") %>%
  select(tract, denial:rate_spread)

jfco_sf %<>% left_join(home_loan_tract, by = c("GEOID" = "tract"))

loan_num_labs <- c("No mortgages", "Less than 1", "1 to 3", "3 to 5", "5 to 10", "More than 10")

jfco_sf %<>%
  mutate(
    loan_num_fill = 
      case_when(
        loan_number_per_100 == 0 ~ loan_num_labs[1],
        loan_number_per_100 <= 1 ~ loan_num_labs[2],
        loan_number_per_100 <= 3 ~ loan_num_labs[3],
        loan_number_per_100 <= 5 ~ loan_num_labs[4],
        loan_number_per_100 <= 10 ~ loan_num_labs[5],
        loan_number_per_100 > 10 ~ loan_num_labs[6],
        is.na(loan_number_per_100) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = loan_num_labs, ordered = TRUE))

ggplot(jfco_sf) + 
  geom_sf(aes(fill = loan_num_fill)) +
  scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        legend.title = element_blank()) +
  labs(title = "Mortgages issued per 100 residents in 2019") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))
```

### Mortgages by race

We can also examine mortgage data by race. Black residents in Louisville received fewer than half the number of mortgages per person that White residents did in 2019.

```{r mortgage_number_race}

# Interactive Mortgage map
# load("home_loans_detail.RData")
# home_loan_detail %<>%
#   select(tract, year, race, sex, loan_status, income, loan, rate) %>%
#   mutate(tract = str_extract(tract, "21111.*")) %>%
#   filter(year == 2019, loan_status == "approved")
# 
# num_points <- home_loan_detail %>%
#   group_by(tract) %>%
#   summarise(n = n(), .groups="drop") %>%
#   left_join(glptools::map_tract, by = "tract") %>%
#   group_by(tract) %>%
#   nest() %>%
#   mutate(points = map(data, function(x) st_sample(x$geometry, x$n))) %>%
#   unnest()
# 
# home_loan_detail %<>% arrange(tract)
# num_points %<>% arrange(tract)
# 
# st_geometry(home_loan_detail) <- num_points$points
# 
# library(leaflet)
# 
# 
# fillpal <- colorFactor(RColorBrewer::brewer.pal(5, "Dark2"), domain = unique(home_loan_detail$race))
# 
# leaflet(filter(home_loan_detail, is.na(race))) %>%
#   addCircleMarkers(
#     radius = ~sqrt(loan / 30000),
#     #radius = 5,
#     stroke=T,
#     fillColor = ~fillpal(race),
#     color = ~fillpal(race),
#     weight = 1,
#     fillOpacity = 0.15,
#     opacity = 0.4) %>%
#   addLegend(pal = fillpal, values = unique(home_loan_detail$race)) %>%
#   addTiles()


mortgage_county <- home_loan_county

plt_by <- function(df, group_var, var, title_text = "Home Mortgages", 
                   y_axis = "Percent", y_min = NA, units = "number") {
  var <- enquo(var)
  group_var <- enquo(group_var)

  text_scale <- 1
  
  plt <- ggplot(data = df, aes(x = year, y = !!var, group = !!group_var, colour = !!group_var)) +
    geom_point(size = 2) +
    geom_line(size = .65) +
    theme_bw() +
    labs(title = title_text, x = "Year", y = y_axis) +
    theme(legend.position = "bottom")
  
  plt <- plt  + 
    scale_colour_manual(values = c("#323844", "#d63631")) +
    scale_x_continuous(breaks = seq(from = 2007, to = 2019, by = 2)) +
    theme(text = element_text(family = "Montserrat"),
          
          legend.title     = element_text(size = 30 * text_scale),
          legend.text      = element_text(size = 24 * text_scale,
                                          margin = margin(b = 0.2 * text_scale, t = 0.2 * text_scale, unit = "cm")),

          axis.text    = element_text(size = 24 * text_scale),
          axis.title   = element_text(size = 30 * text_scale),
          axis.title.x = element_text(margin = margin(t = 0.3 * text_scale, unit = "cm")),
          axis.title.y = element_text(margin = margin(r = 0.3 * text_scale, unit = "cm")),
      
          plot.title = element_text(size = 42 * text_scale,
                                    hjust = .5,
                                    margin = margin(b = 0.4 * text_scale, unit = "cm")))
  
  if (!is.na(y_min)) {
    plt <- plt + ylim(y_min, NA)
  }
  
  if(units == "Dollars") plt <- plt + scale_y_continuous(labels = scales::dollar)
  if(units == "Percent") plt <- plt + scale_y_continuous(labels = function(x) scales::percent(x, accuracy = 1, scale = 1))

  plt <- plt +
    theme(
      panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
      plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
      legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
      legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
      legend.key = element_rect(fill = "transparent",colour = NA)
  )
  
  plt
}

mortgage_county %<>% filter(FIPS == "21111", sex=="total", race %in% c("black", "white")) %>%
  rename(Race = race) %>%
  mutate(Race = str_to_title(Race))

plt_by(mortgage_county, Race, loan_number_per_100, "Mortgages by race", y_axis = "Mortgages per 100 People", y_min = 0)
```

### Mortgage Dollars by race

The racial disparity is mortgages is even larger when you incorporate the dollar amount of mortgages issues. In 2019, white residents received \$2.60 in mortgages for every \$1 that Black residents received after adjusting for population size.

```{r mortgage_dollars_race}
plt_by(mortgage_county, Race, loan_amount_pp, "Mortgage Lending by race", y_axis = "Dollars per 100 People", y_min = 0,
       units = "Dollars")
```

### Denial Rates by Race

Black residents are denied mortgages at a rate roughly twice that of white residents. The mortgage denial rate for Black residents has decreased from a high of 29% in 2008 to a low of 14% in 2019. However, it has not shown signs of decreasing in recent years, and Black residents are more likely to be impacted by the economic impacts of COVID-19, worsening the disparity in 2020 and beyond.

```{r mortgage_denial_race}
plt_by(mortgage_county, Race, denial, "Mortgage Denial by race", y_axis = "Denial Rate", y_min = 0, units= "Percent")
```

### Denial Rates by Geography

A major factor in mortgage availability is denial rates. While some areas of town saw few to no mortgage denials, people in many parts of West Louisville experienced denial rates of 30 to 40%.

```{r mortgage_denial}
make_map(denial, title = "Mortgage Denial Rate in 2019", 
         legend = "Percent", 
         caption = "Denial rate")
```

### Interest Rates by geography

For the mortgages that were issued, interest rates varied from around 3.5% to around 5%. While the average interest rate was around 4% for the much of East Louisville, average interest rates in West Louisville were closer to 5%. A 30-year mortgage with an interest rate of 5% requires monthly payments that are 13% higher than a mortgage with an interest rate of 4%.

```{r mortgage_interest}
make_map(rate, title = "Mortgage Interest Rate in 2019", 
         legend = "Percent", 
         caption = "Interest rate")
```

## Housing Price Changes

As Louisville grows, increasing home prices reflect changes in inflation and increasing demand for homes. Long-term growth in home prices helps homeowners build equity and wealth. Short-term appreciation can be a boon to homeowners with the finances to stay in their home, though it also causes many homeowners and renters to be dislocated from their neighborhood.

### Long-term appreciation

This map shows the change in existing home prices across zip codes since 2000, controlling for new construction. Since 2000, existing homes in Louisville have increased in value by an average of 57% (an average of about 2.4% per year). However, not every area of the city has benefited equally from this growth. Home prices in zip code 40204, which contains the Upper Highlands and Germantown, have more than doubled since 2000. While many zip codes close to downtown also saw high growth, many parts of West Louisville saw slow growth, and homes in 40212 lost value.

```{r long_term_appreciation}
lou_num <- HPI_county %>% filter(FIPS == "21111")

housing_price_index <- HPI_zip

housing_price_index %<>% 
  filter(year == 2019)

map_zip %<>% left_join(housing_price_index, by = "zip")

hpi_change <- c("Lost value", "0% - 25%", "25% - 50%", "50% - 75%", "75% - 100%", "100% - 125%")
hpi_2015_change <- c("Lost value", "0% - 10%", "10% - 20%", "20% - 30%", "30% - 40%", "40% - 50%")

map_zip %<>%
  mutate(
    hpi_fill = 
      case_when(
        HPI < 100 ~ hpi_change[1],
        HPI < 125 ~ hpi_change[2],
        HPI < 150 ~ hpi_change[3],
        HPI < 175 ~ hpi_change[4],
        HPI < 200 ~ hpi_change[5],
        HPI < 225 ~ hpi_change[6],
        is.na(HPI) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = hpi_change, ordered = TRUE),
    hpi_2015_fill = 
      case_when(
        HPI_2015 < 0 ~ hpi_2015_change[1],
        HPI_2015 < 10 ~ hpi_2015_change[2],
        HPI_2015 < 20 ~ hpi_2015_change[3],
        HPI_2015 < 30 ~ hpi_2015_change[4],
        HPI_2015 < 40 ~ hpi_2015_change[5],
        HPI_2015 < 50 ~ hpi_2015_change[6],
        is.na(HPI) ~ NA_character_,
        TRUE ~ "error!!") %>%
      factor(levels = hpi_2015_change, ordered = TRUE))

ggplot(map_zip) + 
  geom_sf(aes(fill = hpi_fill)) +
  scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  #scale_fill_viridis() +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        legend.title = element_blank()) +
  labs(title = "Change in housing prices since 2000") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))
```

### Short-term appreciation

Looking at the growth since 2015 highlights zip codes where changes in home prices have been very acute. The average home in Louisville increased in value by 21% between 2015 and 2019. The vast majority of zip codes saw total growth of 10% - 30%, while changes in home prices for zip codes in West Louisville range from a decrease of 30% in 40212 to an increase of 40% in 40203. The rapid price increase in 40203, which contains parts of Russell and Old Louisville, threaten to displace many residents. In 40203, home prices across Louisville increased by an average of 8.8% per year.

```{r short_term_appreciation}
ggplot(map_zip) + 
  geom_sf(aes(fill = hpi_2015_fill)) +
  scale_fill_manual(values = viridis::viridis(6, direction = -1), na.value = "grey") +
  #scale_fill_viridis() +
  theme_bw(base_size = 22, base_family = "Montserrat") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank(),
        legend.title = element_blank()) +
  labs(title = "Change in housing prices since 2015") +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```

## Housing Availability

Housing must be both affordable and available for families to have housing that meets their needs. Based on framework from the Housing Needs Assessment, we compare households' incomes to the price of housing available to them.

We use the Area Median Income (AMI) to group households and housing units. In 2019, the AMI for Louisville was \$76,400 for a family of four. (The AMI adjusts for household size.) We also use AMI to group homes and apartments by determining whether the housing would be affordable to households in that income group. Housing is affordable is a household spends less than 30% of their income on housing costs. For a fuller explanation of AMI, see the next section.

We find that households making less than 30% of AMI do not have enough housing units available to them. While 39,000 households have incomes below 30% of AMI, there are only enough affordable and available units for about half of them of them.

This creates an affordability gap for households making between 30% and 50% of AMI. While there are actually more housing units than households at this income level, many of them are occupied by households with lower incomes, making them unavailable. The same problem exists for households in the 80% AMI income group.

At higher income levels, we find that households generally have access to affordable housing.

Creating housing opportunities for households below 30% of AMI would help ease the housing gap not only for them, but for households in higher income groups as well.


```{r housing_availability, message=FALSE, warning=FALSE, eval=FALSE}
library(magrittr)

acs_micro_houses_ddi <- ipumsr::read_ipums_ddi("housing_data/usa_00083.xml")
acs_houses_unoccupied <- ipumsr::read_ipums_micro(acs_micro_houses_ddi, verbose=F)

acs_houses_unoccupied %<>% clean_acs_micro()

acs_houses_unoccupied %<>% 
  filter(FIPS == "21111",
         year %in% 2015:2019)

acs_micro <- arrow::read_feather("../glpdata/data-raw/microdata/acs_micro.feather")

# Create table of AMI limits based on HUD information
mult = c(0.7, 0.8, 0.9, 1 + seq(0, 0.64, by = 0.08))

mult_br = c(0.7, 0.75, 0.9, 1.04 + seq(0, 0.88, by = 0.12))

ami_table_16 <- data.frame(
  hh_size = rep(1:12),
  ami30    = c(15050, 17200, 20780, 25100, 29420, 33740, 38060, 42380, 
               plyr::round_any(42380 + (42380 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami50    = c(25050, 28600, 32200, 35750, 38650, 41500, 44350, 47200, 
               plyr::round_any(47200 + (47200 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami80    = c(40050, 45800, 51500, 57200, 61800, 66400, 70950, 75550, 
               plyr::round_any(75550 + (75550 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami100   = 71500 * mult,
  ami150   = 71500 * mult * 1.5,
  ami200   = 71500 * mult * 2)

ami_table_16_house <- ami_table_16 %>%
  transmute(
    bedrooms = hh_size - 1,
    ami30_house = ami30,
    ami50_house = ami50,
    ami80_house = ami80,
    ami100_house = ami100,
    ami150_house = ami150, 
    ami200_house = ami200)

ami_table_19 <- data.frame(
  hh_size = rep(1:12),
  ami30    = c(16050, 18350, 21330, 25750, 30170, 34590, 39010, 43430, 
               plyr::round_any(43430 + (43430 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami50    = c(26750, 30600, 34400, 38200, 41300, 44350, 47400, 50450,
               plyr::round_any(50450 + (50450 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami80    = c(42800, 48900, 55000, 61100, 66000, 70900, 75800, 80700, 
               plyr::round_any(75550 + (75550 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami100   = plyr::round_any(76400 * mult, 50, ceiling),
  ami150   = plyr::round_any(76400 * mult * 1.5, 50, ceiling),
  ami200   = plyr::round_any(76400 * mult * 2, 50, ceiling))

# Calculate household size, subset, and add AMI dataframe
acs_micro %<>%
  filter(
    FIPS == "21111",
    year %in% 2015:2019,
    OWNERSHP != 0) %>%
  group_by(year, SERIAL) %>%
  mutate(hh_size = n()) %>%
  ungroup() %>%
  filter(PERNUM == 1)

# Calculate adjustment factor for renters who did not report utilty information
utility_adjust <- acs_micro %>%
  filter(
    #vacant |
    RENTGRS > RENT) %>%
  mutate(utility_est = (RENTGRS - RENT) / RENT) %>%
  summarise(utiity_est = Hmisc::wtd.quantile(utility_est, HHWT, probs = 0.5, na.rm = T)) %>%
  pull(utiity_est) %>%
  unname()

# Process microdata
acs_micro %<>%
  mutate(
    
    # Recode missing values
    OWNCOST  = replace(OWNCOST, OWNCOST == 99999, NA),
    HHINCOME = replace(HHINCOME, HHINCOME == 99999, NA),
    OWNERSHP = replace(OWNERSHP, OWNERSHP == 0, NA),
    RENTGRS  = case_when(
      RENTGRS == 0 & OWNERSHP == 1 ~ NA_real_,
      RENTGRS == RENT ~ RENT * (1 + utility_adjust),
      TRUE ~ RENTGRS),
    
    BEDROOMS = case_when(
      BEDROOMS == 0 ~ NA_real_,
      BEDROOMS >= 1 ~ BEDROOMS -1),

    # calculate homeownership and cost burden
    homeownership = if_else(OWNERSHP == 1, 1, 0),
    hcost = if_else(homeownership == 1, OWNCOST, RENTGRS),
    cost_burden = if_else(hcost * 12 / HHINCOME > 0.3, 1, 0),
    severe_cost_burden = if_else(hcost * 12 / HHINCOME > 0.5, 1, 0),

    hh_type = case_when(
      homeownership == 1 & cost_burden == 0 ~ "noncb_homeowner",
      homeownership == 1 & cost_burden == 1 ~ "cb_homeowner",
      homeownership == 0 & cost_burden == 0 ~ "noncb_renter",
      homeownership == 0 & cost_burden == 1 ~ "cb_renter",
      TRUE ~ NA_character_))  %>%
  # Adjust HHICOME for inflation
  COLA(HHINCOME, base_year = 2019, rpp = F) %>%
  left_join(ami_table_19, by = "hh_size") %>%
  mutate(
    hh_ami_group = case_when(
      HHINCOME < ami30  ~ 30,
      HHINCOME < ami50  ~ 50,
      HHINCOME < ami80  ~ 80,
      HHINCOME < ami100 ~ 100,
      HHINCOME < ami150 ~ 150,
      HHINCOME < ami200 ~ 200,
      TRUE ~ Inf))
  
  
# Tidy data for unoccupied houses
acs_houses_unoccupied %<>%
  mutate(
    vacancy = case_when(
      VACANCY == 0 ~ "occupied",
      VACANCY %in% 1:2 ~ "available",
      VACANCY %in% 3:9 ~ "unavailable")) %>%
  filter(vacancy %in% c("available")) %>%
  transmute(
    FIPS, year, HHWT,
    homeownership = if_else(VACANCY == 2, 1, 0),
    RENTGRS = RENT * (1 + utility_adjust),
    RENT,
    VALUEH,
    BEDROOMS = case_when(
      BEDROOMS == 0 ~ NA_real_,
      BEDROOMS >= 1 ~ BEDROOMS -1),
    VACANCY)

# Bind data to occupied houses
acs_houses <- acs_micro %>%
  bind_rows(acs_houses_unoccupied) %>%
  
  # Adjust for inflation
  COLA(RENTGRS, VALUEH, base_year = 2019, rpp = F) %>%
  mutate(
    
    # Reverse cost-burden calc to test AMI category of home
    # Per HNA, mortgage of $279,307 corresponds to a rent ceiling of $1,787
    est_cost = case_when(
      homeownership == 0 ~ RENTGRS * 12,
      homeownership == 1 ~ VALUEH / 279307 * 1787 * 12),
    
    min_income = est_cost / 0.3,
    
    br_pp    = min_income * mult[BEDROOMS + 1],
    br_p1.5p = min_income * mult_br[BEDROOMS + 1],
    ami_pct = br_p1.5p / 71500 * 100,
    
    adj_income = HHINCOME * mult[hh_size]) %>%
  mutate(
    # house_ami_group = case_when(
    #   br_p1.5p < (71500 * 0.3)  ~ 30,
    #   br_p1.5p < (71500 * 0.5)  ~ 50,
    #   br_p1.5p < (71500 * 0.8)  ~ 80,
    #   br_p1.5p < (71500 * 1) ~ 100,
    #   br_p1.5p < (71500 * 1.5) ~ 150,
    #   br_p1.5p < (71500 * 2) ~ 200,
    #   TRUE ~ Inf)) %>%
    house_ami_group = case_when(
      br_p1.5p < (76400 * 0.3)  ~ 30,
      br_p1.5p < (76400 * 0.5)  ~ 50,
      br_p1.5p < (76400 * 0.8)  ~ 80,
      br_p1.5p < (76400 * 1) ~ 100,
      br_p1.5p < (76400 * 1.5) ~ 150,
      br_p1.5p < (76400 * 2) ~ 200,
      TRUE ~ Inf)) %>%
  mutate(
    hh_ami_group = replace_na(hh_ami_group, 0),
    available = if_else(VACANCY %in% 1:2 | adj_income >= br_p1.5p, 1, 0)) %>%
    #available = if_else(VACANCY %in% 1:2 | hh_ami_group <= house_ami_group, 1, 0)) %>%
  select(year, HHWT, RENT, RENTGRS, VALUEH, VACANCY, OWNERSHP, BEDROOMS, hh_size, homeownership, 
         hh_ami_group, est_cost, min_income, br_pp, br_p1.5p, ami_pct, house_ami_group, available)

results_people <- acs_micro %>%
  group_by(homeownership, hh_ami_group) %>%
  summarise(households = sum(HHWT) / 5, .groups = "drop") %>%
  rename(ami_group = hh_ami_group)

sum_avail <- function(df, value) {
  filter(df, hh_ami_group <= value, house_ami_group <= value) %>%
    group_by(homeownership) %>%
    summarise(
      ami_group = value,
      houses = sum(HHWT) / 5, .groups="drop")
}

results_30 <- sum_avail(acs_houses, 30)
results_50 <- sum_avail(acs_houses, 50)
results_80 <- sum_avail(acs_houses, 80)
results_100 <- sum_avail(acs_houses, 100)
results_150 <- sum_avail(acs_houses, 150)
results_200 <- sum_avail(acs_houses, 200)
results_Inf <- sum_avail(acs_houses, Inf)

results_houses <- bind_rows(results_30, results_50, results_80, results_100, results_150, results_200, results_Inf)

# actual <- data.frame(
#   homeownership = c(rep(0:1, each = 7)),
#   level = rep(c(30, 50, 80, 100, 150, 200, Inf), 2),
#   report_num = c(17563, 46023, 89538, 98513, 115443, 121556, NA_real_, 8404, 19788, 54031, 75898, 120394, 148999, NA_real_))

# results_houses %<>%
#   left_join(actual) %>%
#   mutate(dif = (freq - report_num) / report_num * 100)

results <- full_join(results_people, results_houses)

library(ggtext)

results %<>%
  group_by(ami_group) %>%
  summarise(across(households:houses, sum), .groups = "drop")

group_avail <- function(df, value) {
  df %>%
    filter(ami_group <= value) %>%
    mutate(ami = value)
}

results$houses[2:7] = results$houses[2:7] - results$houses[1:6]

results %<>%
  mutate(
    households_cumsum = cumsum(households),
    homes_cumsum = cumsum(houses),
    lab_color = viridis(7, direction = -1)[2:7][match(ami_group, c(30, 50, 80, 100, 150, 200))],
    label = paste0("<span style='font-size:36pt'>", 
                   scales::percent(homes_cumsum / households_cumsum, accuracy = 1), "</span>",
                   "<span style='font-size:12pt'><br>of households<br>up to<br></span>",
                   "<span style='font-size:20pt; face:bold; color:", lab_color, "'>", 
                   ami_group, "% AMI", "</span>"))

results_30 <- group_avail(results, 30)
results_50 <- group_avail(results, 50)
results_80 <- group_avail(results, 80)
results_100 <- group_avail(results, 100)
results_150 <- group_avail(results, 150)
results_200 <- group_avail(results, 200)

results_graph <- bind_rows(results_30, results_50, results_80, results_100, results_150, results_200)

results_graph %<>%
  pivot_longer(households:houses, names_to = "obs_type", values_to = "value") %>%
  mutate(
    ami_group = factor(ami_group, 
                       levels = c(200, 150, 100, 80, 50, 30),
                       labels = c(200, 150, 100, 80, 50, 30),
                       ordered = T),
    ami = factor(ami, labels = unique(label))) %>% 
  arrange(ami_group)


ggplot(results_graph, aes(x = obs_type, y = value, fill = ami_group)) + 
  geom_col(position = 'stack') + 
  scale_fill_manual(values = viridis(7, direction = -1)[2:7],
                    breaks = rev(c(200, 150, 100, 80, 50, 30)),  
                    guide = guide_legend(reverse = TRUE),
                    name = "AMI Group") +
  facet_grid(~ ami) + 
  theme_bw(base_family = "Montserrat", base_size = 22) +
  theme(
    panel.grid = element_blank(),
    panel.spacing.y = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_markdown(margin=margin(-20)),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    panel.border = element_blank(),
    strip.background = element_blank(),
    plot.subtitle = element_text(hjust = 0, lineheight = 0.5),
    legend.title = element_text(size = 24),
    strip.text.x = element_markdown(lineheight = 0.6),
    strip.placement = "outside",
    plot.title = element_text(size = 32),
    plot.caption = element_text(size = 16, lineheight = 0.5, hjust = 0)) + 
  scale_y_continuous(expand = c(.15, 0)) +
  geom_text(
    aes(label = scales::number(stat(y), scale = .001, accuracy = 1, suffix = "K"), group = ami), 
    stat = 'summary', fun = sum, vjust = -1, size = 6, family = "Montserrat") +
  labs(title = "Affordability Gaps",
       subtitle = "There are enough available and affordable homes for...",
       caption = "Within each group, the bar on the left represents the number of households at that income level\nand the bar on the right represents the number of homes that are available and affordable to them.") +
  scale_x_discrete(
    name = NULL,
    labels = c(households = "<img src='001-family.png' width='16'/>",
           houses = "<img src='002-house-black-silhouette-without-door.png' width='16'/>")) +
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), # bg of the panel
    plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
    legend.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent", color = "transparent"), # get rid of legend panel bg
    legend.key = element_rect(fill = "transparent",colour = NA))

```


The table below shows the cutoffs for family income, monthly rent, and home purchase prices for each AMI group.

We group residents by percentages of the Area Median Income (AMI) as determined by the Department of Housing and Urban Development. In 2019, the AMI for a four-person household in Louisville was \$76,300. Median income means 50% of four-person families earned less than the AMI, and 50% earned more. The AMI is adjusted down for smaller households and up for larger households. For example, the AMI for a person living alone is \$54,000, and the AMI for a six-person household is \$89,000.

Households in the 30% AMI income group have income less than or equal to the Federal Poverty Level (about 30% of \$76,300). Households in the 50% AMI group have income between the Federal Poverty Level and 50% of the AMI. Households in the 80% AMI income group have income between 50% of the AMI and 80% of the AMI, and so on for higher AMI levels.

We group homes and apartments by AMI by determining the minimum income needed for a household to live there affordably (without spending more than 30% of their income on housing costs). We adjust housing costs by bedroom size to align with how the AMI for households is adjusted by household size.

We determine the AMI group of apartments using monthly rent and utilities. We determine the AMI group of homes based on the value of the home in order to measure the affordability of homeownership for new buyers, rather than cost-burden for existing homeowners. Based on the conversion used in the Housing Needs Assessment, we calculate that the annual cost of homeownership is about 1/13th of the home's value.

More details on the methodology can be found in the Housing Needs Assessment and the Housing Needs Assessment Methodology:
https://loutrustfund.org/wp-content/uploads/2019/02/HNA_Appendix_190130.pdf
https://secureservercdn.net/166.62.110.60/7nm.5c8.myftpupload.com/wp-content/uploads/2019/02/HNA_FINAL_190222.pdf


```{r, eval=FALSE}
ami_table_19 <- data.frame(
  hh_size = rep(1:12),
  ami30    = c(16050, 18350, 21330, 25750, 30170, 34590, 39010, 43430, 
               plyr::round_any(43430 + (43430 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami50    = c(26750, 30600, 34400, 38200, 41300, 44350, 47400, 50450,
               plyr::round_any(50450 + (50450 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami80    = c(42800, 48900, 55000, 61100, 66000, 70900, 75800, 80700, 
               plyr::round_any(75550 + (75550 / 1.32 * 0.08) * 1:4, 50, ceiling)),
  ami100   = plyr::round_any(76400 * mult, 50, ceiling),
  ami150   = plyr::round_any(76400 * mult * 1.5, 50, ceiling),
  ami200   = plyr::round_any(76400 * mult * 2, 50, ceiling))

ami_table_19 %<>%
  pivot_longer(ami30:ami200, names_to = "ami", values_to = "value") %>%
  mutate(
    rent = value * 0.3 / 12,
    mortgage = rent / 1787 * 279307) %>% 
  pivot_wider(names_from = ami, values_from = value:mortgage)

library(gt)

ami_19 <- ami_table_19 %>%
  gt() %>%
  tab_header(title = "Area Median Incomes, Rents, and Purchase Price Limits by Household Size") %>%
  fmt_currency(columns = vars(value_ami30, value_ami50, value_ami80, value_ami100,
                            value_ami150, value_ami200,
                            mortgage_ami30, mortgage_ami50, mortgage_ami80, mortgage_ami100,
                            mortgage_ami150, mortgage_ami200),
              decimals = 0,
              suffixing =T) %>%
  fmt_currency(columns = vars(rent_ami30, rent_ami50, rent_ami80, rent_ami100,
                              rent_ami150, rent_ami200),
            decimals = 1,
            suffixing =T) %>%
  cols_label(
    hh_size = "Household Size",
    value_ami30 = "Annual Income", 
    value_ami50 = "Annual Income", 
    value_ami80 = "Annual Income",
    value_ami100 = "Annual Income",
    value_ami150 = "Annual Income", 
    value_ami200 = "Annual Income",
    rent_ami30 = "Monthly Rent Ceiling", 
    rent_ami50 = "Monthly Rent Ceiling",
    rent_ami80 = "Monthly Rent Ceiling",
    rent_ami100 = "Monthly Rent Ceiling",
    rent_ami150 = "Monthly Rent Ceiling", 
    rent_ami200 = "Monthly Rent Ceiling",
    mortgage_ami30 = "Purchase Price Ceiling", 
    mortgage_ami50 = "Purchase Price Ceiling", 
    mortgage_ami80 = "Purchase Price Ceiling", 
    mortgage_ami100 = "Purchase Price Ceiling",
    mortgage_ami150 = "Purchase Price Ceiling",
    mortgage_ami200 = "Purchase Price Ceiling") %>%
  # cols_move(columns = vars(perc_cost_burdened_under_35k, perc_renters, perc_poverty_12mnth, perc_unemployed_laborforce, perc_overcrowding_renter_1.50_or_more, housing_instability_index),
  #           after = vars(district)) %>%
  tab_spanner(
    label = "30% AMI",
    columns = vars(value_ami30, rent_ami30, mortgage_ami30)
  ) %>%
  tab_spanner(
    label = "50% AMI",
    columns = vars(value_ami50, rent_ami50, mortgage_ami50)
  ) %>%
  tab_spanner(
    label = "80% AMI",
    columns = vars(value_ami80, rent_ami80, mortgage_ami80)
  ) %>%
  tab_spanner(
    label = "100% AMI",
    columns = vars(value_ami100, rent_ami100, mortgage_ami100)
  ) %>%
  tab_spanner(
    label = "150% AMI",
    columns = vars(value_ami150, rent_ami150, mortgage_ami150)
  ) %>%
  tab_spanner(
    label = "200% AMI",
    columns = vars(value_ami200, rent_ami200, mortgage_ami200)
  ) %>%
  cols_align(align = "center") %>%
    tab_source_note(
    source_note = md("Greater Louisville Project")
  ) %>%
  tab_source_note(
    source_note = md("Analysis framework from the 2019 Housing Needs Assessment.")
  ) %>%
  opt_row_striping(row_striping = TRUE) %>%
  opt_table_outline() %>%
  tab_options(
    table.font.size = px(12),
    table.width = pct(50)
  ) 

ami_19


```

<!--chapter:end:urban_index.Rmd-->

